Here's how the Dice game will work:

Betting: Users can set a bet amount.
Roll Under/Over: Users choose whether the roll will be under or over a target number.
Target Number: Users can adjust a target number (e.g., if "Roll Under" is selected, rolling a number less than or equal to the target wins; if "Roll Over" is selected, rolling a number greater than or equal to the target wins). This target number will affect the payout multiplier.
Roll: When the user clicks "ROLL", a dice roll occurs (simulated).
Win/Loss: The game determines if the user won or lost based on their bet and the roll.
Balance Update: The user's balance is updated accordingly.
History: Recent game results are displayed.
Animations: Basic animations for the dice roll and win/loss states.
Let's break down the code for the Dice game:

DicePage.tsx
This will be similar to your SlotsPage.tsx, providing the layout and including the DiceGame component, "How to Play" instructions, and "Recent Winners" list.

TypeScript

import { MainLayout } from "@/components/layout/MainLayout";
import { DiceGame } from "@/components/games/DiceGame"; // Import the new DiceGame component
import { WinnersList } from "@/components/common/WinnersList";
import { CurrencySelector } from "@/components/common/CurrencySelector";
import { motion } from "framer-motion";

export default function DicePage() {
  return (
    <MainLayout>
      <div className="px-4 lg:px-6 mb-8">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl lg:text-2xl font-bold font-heading">Shadow Dice</h2>
            <CurrencySelector />
          </div>
          <DiceGame /> {/* Use the DiceGame component */}
        </motion.div>
      </div>

      <div className="px-4 lg:px-6 mb-8">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.2 }}
        >
          <h2 className="text-xl lg:text-2xl font-bold font-heading mb-4">How to Play</h2>
          <div className="bg-background-light rounded-xl p-6">
            <ol className="list-decimal list-inside space-y-2 text-gray-300">
              <li>Enter your bet amount in the input field.</li>
              <li>Choose "Roll Under" or "Roll Over" and set your target number.</li>
              <li>Click the "ROLL" button to start the game.</li>
              <li>If your roll meets the condition, you win!</li>
              <li>Your winnings will be automatically added to your balance.</li>
            </ol>
            <div className="mt-4 p-4 bg-background-darker rounded-lg">
              <p className="text-sm text-accent-gold font-semibold">Pro tip:</p>
              <p className="text-sm text-gray-400">Adjust the target number to change your risk and potential reward.</p>
            </div>
          </div>
        </motion.div>
      </div>

      <div className="px-4 lg:px-6 mb-8">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.3 }}
        >
          <h2 className="text-xl lg:text-2xl font-bold font-heading mb-4">Recent Winners</h2>
          <WinnersList />
        </motion.div>
      </div>
    </MainLayout>
  );
}

DiceGame.tsx
This component will contain the game logic, UI for betting, dice display, and interaction.

TypeScript

import { useState, useMemo } from "react";
import { useMutation } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useCurrency } from "@/providers/CurrencyProvider";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { CurrencyDisplay } from "@/components/common/CurrencyDisplay";
import { Loader2 } from "lucide-react";
import { motion } from "framer-motion";
import { useToast } from "@/hooks/use-toast";
import { GameType } from "@shared/schema"; // Assuming GameType is defined in your shared schema

interface DiceGameResult {
  isWin: boolean;
  winAmount: number;
  multiplier: number;
  gameData: {
    roll: number;
    target: number;
    rollType: 'under' | 'over';
  };
}

export function DiceGame() {
  const { user } = useAuth();
  const { currency: currentCurrency, getCurrencySymbol } = useCurrency();
  const currencySymbol = getCurrencySymbol(currentCurrency);
  const { toast } = useToast();

  const [betAmount, setBetAmount] = useState("0.001");
  const [rollType, setRollType] = useState<'under' | 'over'>('under');
  const [targetNumber, setTargetNumber] = useState(50); // Default target for 1-100 range
  const [isRolling, setIsRolling] = useState(false);
  const [diceRoll, setDiceRoll] = useState<number | null>(null);
  const [history, setHistory] = useState<{ isWin: boolean; amount: string; roll: number; target: number; rollType: 'under' | 'over' }[]>([]);

  // Calculate potential win based on target number and roll type
  const potentialMultiplier = useMemo(() => {
    if (rollType === 'under') {
      // For "roll under N", the probability of winning is N/100
      // So, multiplier = 100 / N (approximately, accounting for 0 or 100 edge cases)
      // To avoid division by zero or very large multipliers for very low N:
      if (targetNumber <= 1) return 99; // Very low chance
      return parseFloat((99 / targetNumber).toFixed(2));
    } else {
      // For "roll over N", the probability of winning is (100 - N + 1)/100
      // Multiplier = 100 / (100 - N + 1)
      if (targetNumber >= 99) return 99; // Very low chance
      return parseFloat((99 / (100 - targetNumber + 1)).toFixed(2));
    }
  }, [targetNumber, rollType]);

  const possibleWin = parseFloat(betAmount) * potentialMultiplier;

  const rollMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest("POST", "/api/games/play", {
        gameType: GameType.DICE, // Use the new GameType.DICE
        betAmount: parseFloat(betAmount),
        currency: currentCurrency,
        gameData: {
          rollType,
          target: targetNumber,
        },
      });
      return res.json() as Promise<DiceGameResult>;
    },
    onSuccess: (data) => {
      setDiceRoll(data.gameData.roll);

      setHistory(prev => [
        {
          isWin: data.isWin,
          amount: data.isWin ? data.winAmount.toString() : betAmount,
          roll: data.gameData.roll,
          target: data.gameData.target,
          rollType: data.gameData.rollType,
        },
        ...prev.slice(0, 5) // Keep last 5 entries
      ]);

      if (data.isWin) {
        toast({
          title: "You won!",
          description: `You won ${data.winAmount.toFixed(currentCurrency === 'USD' ? 2 : 8)} ${currentCurrency}`,
          variant: "default",
        });
      } else {
        toast({
          title: "You lost",
          description: `You lost ${parseFloat(betAmount).toFixed(currentCurrency === 'USD' ? 2 : 8)} ${currentCurrency}`,
          variant: "destructive",
        });
      }

      queryClient.invalidateQueries({ queryKey: ["/api/wallet/balance"] });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
    onSettled: () => {
      setTimeout(() => {
        setIsRolling(false);
      }, 1500); // Simulate roll animation duration
    }
  });

  const handleRoll = () => {
    if (!user) {
      toast({
        title: "Not logged in",
        description: "Please log in to play.",
        variant: "destructive",
      });
      return;
    }

    const betValue = parseFloat(betAmount);
    if (isNaN(betValue) || betValue <= 0) {
      toast({
        title: "Invalid bet",
        description: "Please enter a valid bet amount",
        variant: "destructive",
      });
      return;
    }

    if (targetNumber < 1 || targetNumber > 99) {
      toast({
        title: "Invalid Target",
        description: "Target number must be between 1 and 99.",
        variant: "destructive",
      });
      return;
    }

    setIsRolling(true);
    setDiceRoll(null); // Clear previous roll visually
    rollMutation.mutate();
  };

  return (
    <div className="bg-background-light rounded-xl overflow-hidden">
      <div className="p-6">
        <div className="mb-6 bg-background-darker rounded-xl p-6 flex items-center justify-center min-h-[120px]">
          {isRolling ? (
            <motion.div
              className="text-6xl font-bold text-accent-gold"
              initial={{ rotate: 0 }}
              animate={{ rotate: 360 }}
              transition={{ duration: 0.5, repeat: Infinity, ease: "linear" }}
            >
              ðŸŽ²
            </motion.div>
          ) : diceRoll !== null ? (
            <motion.div
              className="text-6xl font-bold text-white"
              initial={{ scale: 0.5, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              {diceRoll}
            </motion.div>
          ) : (
            <p className="text-gray-500 text-lg">Roll the dice!</p>
          )}
        </div>

        <div className="grid grid-cols-2 gap-4 mb-6">
          <div className="bg-background-darker rounded-lg p-4">
            <div className="text-sm text-gray-400 mb-1">Bet Amount</div>
            <div className="flex items-center">
              <Input
                type="number"
                value={betAmount}
                onChange={(e) => setBetAmount(e.target.value)}
                className="flex-1 bg-transparent border-none text-white text-lg focus:outline-none"
                disabled={isRolling}
                step="0.001"
                min="0.001"
              />
              <span className="text-white font-medium">{currentCurrency}</span>
            </div>
          </div>

          <div className="bg-background-darker rounded-lg p-4">
            <div className="text-sm text-gray-400 mb-1">Potential Win</div>
            <div className="text-white text-lg font-medium">
              <CurrencyDisplay amount={possibleWin} />
            </div>
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4 mb-6">
          <div className="bg-background-darker rounded-lg p-4">
            <div className="text-sm text-gray-400 mb-2">Roll Type</div>
            <div className="flex space-x-2">
              <Button
                variant={rollType === 'under' ? 'default' : 'outline'}
                onClick={() => setRollType('under')}
                disabled={isRolling}
                className="flex-1"
              >
                Roll Under
              </Button>
              <Button
                variant={rollType === 'over' ? 'default' : 'outline'}
                onClick={() => setRollType('over')}
                disabled={isRolling}
                className="flex-1"
              >
                Roll Over
              </Button>
            </div>
          </div>

          <div className="bg-background-darker rounded-lg p-4">
            <div className="text-sm text-gray-400 mb-1">Target Number (1-99)</div>
            <Input
              type="number"
              value={targetNumber}
              onChange={(e) => setTargetNumber(parseInt(e.target.value) || 1)}
              className="bg-transparent border-none text-white text-lg focus:outline-none"
              disabled={isRolling}
              min="1"
              max="99"
            />
          </div>
        </div>

        <Button
          variant="default"
          className="w-full bg-accent-gold text-background font-bold rounded-lg py-3 text-lg hover:bg-yellow-500 transition-colors"
          onClick={handleRoll}
          disabled={isRolling || rollMutation.isPending}
        >
          {isRolling || rollMutation.isPending ? (
            <span className="flex items-center justify-center">
              <Loader2 className="mr-2 h-5 w-5 animate-spin" />
              ROLLING...
            </span>
          ) : (
            "ROLL"
          )}
        </Button>
      </div>

      <div className="bg-background-darker p-4 border-t border-gray-800">
        <h3 className="font-medium text-white mb-2">Recent Rolls</h3>
        {history.length === 0 ? (
          <p className="text-gray-400 text-sm">No recent rolls</p>
        ) : (
          <div className="grid grid-cols-2 lg:grid-cols-3 gap-2">
            {history.map((item, index) => (
              <div
                key={index}
                className={`${
                  item.isWin ? 'bg-win bg-opacity-20 text-win' : 'bg-loss bg-opacity-20 text-loss'
                } rounded-lg p-2 text-center text-sm`}
              >
                <span className="block font-medium">{item.isWin ? 'Win' : 'Loss'}</span>
                <span className="text-xs">
                  Roll: {item.roll} ({item.rollType === 'under' ? '<=' : '>='} {item.target})
                </span>
                <span className="block text-xs">
                  <CurrencyDisplay amount={item.amount} compact={true} />
                </span>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

Key Changes and Explanations:
DicePage.tsx:

Imports DiceGame instead of SlotsGame.
Updates the <h2> title to "Shadow Dice".
Modifies the "How to Play" instructions to be relevant to a dice game.
DiceGame.tsx:

State Variables:
rollType: 'under' | 'over' to store the user's choice.
targetNumber: The number the user aims to roll under or over (1-99).
isRolling: Boolean to control the rolling animation and disable buttons.
diceRoll: Stores the result of the dice roll (a number between 1 and 100).
history: Stores an array of past game results including roll, target, and rollType.
GameType.DICE: I've assumed you have a GameType enum in your @shared/schema that you can extend to include DICE. If not, you'll need to define it.
potentialMultiplier ( useMemo ):
This is a crucial part of the dice game. It calculates the potential payout multiplier based on the targetNumber and rollType.
The logic is based on probability:
For "Roll Under N": The probability of winning is roughly N/100. The multiplier is then 100/N.
For "Roll Over N": The probability of winning is roughly (100 - N + 1)/100. The multiplier is 100 / (100 - N + 1).
I've added safeguards for extreme target numbers (1 or 99) to prevent division by zero or excessively high multipliers.
useMemo is used to re-calculate this only when targetNumber or rollType changes.
rollMutation (useMutation):
The mutationFn now sends gameType: GameType.DICE and includes gameData with rollType and target to your API. Your backend will need to process this information to determine the dice roll and win/loss.
onSuccess:
Updates diceRoll with the result from the API.
Adds the new game result to the history state.
Displays appropriate toasts for win/loss, including the rolled number and target.
onError: Handles API errors.
onSettled: Sets isRolling to false after a delay to simulate the roll animation.
handleRoll Function:
Performs validation for betAmount and targetNumber.
Sets isRolling to true and clears diceRoll before initiating the mutation.
UI Structure:
Dice Display: Uses motion.div for a spinning dice animation when isRolling and displays the diceRoll result when available.
Bet Amount & Potential Win: Similar to your Slots game.
Roll Type Selection: Two Button components for "Roll Under" and "Roll Over" to toggle rollType.
Target Number Input: An Input field for the user to set their desired target number (1-99).
Roll Button: Triggers the handleRoll function, showing a Loader2 when pending.
Recent Rolls History: Displays the last few game results, including the roll, target, and roll type, with visual indicators for win/loss.
Backend API Considerations (Crucial)
The provided code interacts with an API endpoint /api/games/play. For the Dice game to function correctly, your backend API will need to be updated to:

Handle GameType.DICE: Recognize the GameType.DICE when received in the gameType field of the request.
Process gameData: Extract rollType and target from the gameData object in the request body.
Simulate Dice Roll: Generate a random number between 1 and 100 (or whatever range you prefer for your dice game).
Determine Win/Loss:
If rollType is 'under', check if the roll <= target.
If rollType is 'over', check if the roll >= target.
Calculate Win Amount: Based on the betAmount and the calculated multiplier (which you'd also calculate on the backend to prevent client-side manipulation). The multiplier should be derived from the probability of winning with the chosen target and rollType.
Return DiceGameResult: The API response should match the DiceGameResult interface defined in DiceGame.tsx (i.e., isWin, winAmount, multiplier, and gameData with roll, target, rollType).
Update User Balance: Debit the bet amount on loss, or credit the win amount on win.
Example Backend Logic (Conceptual, Node.js/Express)
JavaScript

// On your backend (e.g., in /api/games/play)

// Assuming you have parsed req.body
const { gameType, betAmount, currency, gameData } = req.body;

if (gameType === GameType.DICE) {
  const { rollType, target } = gameData;

  if (target < 1 || target > 99) {
    return res.status(400).json({ message: "Invalid target number." });
  }

  // Simulate a dice roll (1-100)
  const roll = Math.floor(Math.random() * 100) + 1;

  let isWin = false;
  let winAmount = 0;
  let multiplier = 0;

  if (rollType === 'under') {
    isWin = roll <= target;
    // Calculate multiplier (example: for N=50, prob=50/100, mult=2)
    // Be careful with edge cases for N=1 or N=100
    if (target > 0) {
      multiplier = 99 / target; // Simplified calculation for backend
    } else {
      multiplier = 0; // Should not happen with target > 0
    }
  } else if (rollType === 'over') {
    isWin = roll >= target;
    // Calculate multiplier (example: for N=50, prob=(100-50+1)/100, mult=100/51)
    if ((100 - target + 1) > 0) {
      multiplier = 99 / (100 - target + 1); // Simplified calculation for backend
    } else {
      multiplier = 0; // Should not happen with target < 100
    }
  }

  if (isWin) {
    winAmount = betAmount * multiplier;
    // Update user balance: add winAmount
  } else {
    // Update user balance: subtract betAmount
    winAmount = 0; // No win amount on loss
  }

  // Respond with the result
  return res.json({
    isWin,
    winAmount,
    multiplier,
    gameData: {
      roll,
      target,
      rollType,
    },
  });
}
This comprehensive solution provides both the frontend components and the conceptual backend considerations to seamlessly integrate a Dice game into your existing casino application. Remember to adjust file paths and GameType definition as per your project structure.