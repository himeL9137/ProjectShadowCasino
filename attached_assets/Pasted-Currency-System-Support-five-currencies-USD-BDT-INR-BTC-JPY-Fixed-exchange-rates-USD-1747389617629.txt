Currency System:





Support five currencies: USD, BDT, INR, BTC, JPY.



Fixed exchange rates: USD: 1, BDT: 122.73, INR: 83.27, BTC: 0.000013, JPY: 145.00.



Users can switch currencies anytime, including mid-game (e.g., during a spin in Slots, a roll in Dice, or a drop in Plinko).



Currency preference is saved in SQLite and applied globally via Redux.



Balances are stored in USD internally, converted to the user’s currency for display.



Use WebSocket for real-time balance updates across all components.



Display balances with locale-specific formatting (e.g., ¥14,500 for JPY, ₹8,327 for INR) using Intl.NumberFormat.



Show error alerts if currency switching fails (e.g., network issues).



Games (Slots, Dice, Plinko):





Each game includes a currency selector for mid-game switching.



Implement a biased RNG: 50/50 win chance for balances < 150 (in the user’s currency); otherwise, fixed win chances of 0.8, 0.4, or 0.2. Payout is 1.1x win or loss.



Ensure no disruptions during currency switches (e.g., persist game state like isSpinning).



Bets are validated against the current balance and adjusted post-currency switch.



Disable game actions (e.g., spin, roll, drop) during active gameplay to prevent race conditions.



UI and Styling:





Use Tailwind CSS with a dark purple theme (default for the project).



Ensure responsive, user-friendly design with disabled states for buttons/inputs during gameplay.



Display bets and balances clearly, updated instantly after currency switches.



Backend:





Use Node.js with Express and SQLite for data storage.



Implement endpoints: /api/user/currency (PATCH) for currency updates, /api/user/balance (PATCH) for game balance updates.



Use WebSocket (socket.io) for real-time balance updates.



Assume JWT authentication (middleware sets req.user).



Replit Setup:





Provide a complete file structure compatible with Replit.



Include all dependencies in package.json (e.g., react, redux, socket.io, sqlite3, tailwindcss).



Provide a .replit file or instructions to run the app (e.g., start backend and frontend).



Ensure WebSocket works on Replit’s hosted environment (adjust URL if needed).

Reference Code:

Below is the reference implementation for the currency system and games. Use it as a base, ensuring all requirements are met and optimized for Replit.

// Frontend: src/components/CurrencySelector.tsx
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { setCurrency } from '../redux/slices/userSlice';
import { RootState } from '../redux/store';
import { io } from 'socket.io-client';

const socket = io('http://localhost:5000'); // Adjust for Replit

interface CurrencySelectorProps {
  onCurrencyChange?: () => void;
}

const CurrencySelector: React.FC<CurrencySelectorProps> = ({ onCurrencyChange }) => {
  const dispatch = useDispatch();
  const { currency, balance } = useSelector((state: RootState) => state.user);
  const [error, setError] = useState<string | null>(null);
  const availableCurrencies = ['USD', 'BDT', 'INR', 'BTC', 'JPY'];

  const exchangeRates: { [key: string]: number } = {
    USD: 1,
    BDT: 122.73,
    INR: 83.27,
    BTC: 0.000013,
    JPY: 145.00,
  };

  const formatBalance = (amount: number, curr: string): string => {
    try {
      const locales: { [key: string]: string } = {
        USD: 'en-US',
        BDT: 'bn-BD',
        INR: 'hi-IN',
        BTC: 'en-US',
        JPY: 'ja-JP',
      };
      return new Intl.NumberFormat(locales[curr], {
        style: 'currency',
        currency: curr,
        minimumFractionDigits: curr === 'BTC' ? 8 : 2,
      }).format(amount);
    } catch {
      return `${amount.toFixed(curr === 'BTC' ? 8 : 2)} ${curr}`;
    }
  };

  const handleCurrencyChange = async (newCurrency: string) => {
    try {
      setError(null);
      const response = await fetch('/api/user/currency', {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({ currency: newCurrency }),
      });

      if (!response.ok) throw new Error('Failed to update currency');

      dispatch(setCurrency(newCurrency));
      socket.emit('currencyChange', { userId: localStorage.getItem('userId'), currency: newCurrency });
      if (onCurrencyChange) onCurrencyChange();
    } catch (error) {
      console.error('Currency update error:', error);
      setError('Failed to switch currency. Please try again.');
    }
  };

  useEffect(() => {
    socket.on('balanceUpdate', (data: { balance: number; currency: string }) => {
      dispatch(setCurrency(data.currency));
      if (onCurrencyChange) onCurrencyChange();
    });

    return () => {
      socket.off('balanceUpdate');
    };
  }, [dispatch, onCurrencyChange]);

  return (
    <div className="currency-selector flex items-center gap-2">
      <label htmlFor="currency" className="text-sm">Currency:</label>
      <select
        id="currency"
        value={currency}
        onChange={(e) => handleCurrencyChange(e.target.value)}
        className="p-1 border rounded text-sm"
      >
        {availableCurrencies.map((curr) => (
          <option key={curr} value={curr}>
            {curr}
          </option>
        ))}
      </select>
      <p className="text-sm">{formatBalance(balance, currency)}</p>
      {error && <p className="text-red-500 text-xs">{error}</p>}
    </div>
  );
};

export default CurrencySelector;

// [Include Slots.tsx, Dice.tsx, Plinko.tsx, userSlice.ts, currencyRoutes.ts, index.ts as provided in the previous artifact, with adjustments for Replit]

