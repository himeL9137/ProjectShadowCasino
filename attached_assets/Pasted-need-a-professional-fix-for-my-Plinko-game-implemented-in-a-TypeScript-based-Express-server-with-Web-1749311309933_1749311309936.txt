need a professional fix for my Plinko game implemented in a TypeScript-based Express server with WebSocket integration, running in a development environment using tsx (NODE_ENV=development). The current server-side logic in server/games.ts throws a ReferenceError: require is not defined at line 294 in the processPlinkoMasterGame function, likely due to using CommonJS require in an ES modules context. Additionally, the client-side ball drop animation sometimes shows the ball landing on a high multiplier (e.g., 2x) from the multiplier bar [2.0, 1.8, 1.6, 1.4, 1.0, 0.8, 0.6, 0.4, 0.4, 0.6, 0.8, 1.0, 1.4, 1.6, 1.8], but the server reports a loss with a lower multiplier (e.g., 0.8x, payout ৳0.80 for a ৳1 bet). The game is triggered via a POST request to /api/games/play with parameters like gameType: 'PLINKO_MASTER', betAmount, currency: 'BDT', and numBalls: 1. Please provide an updated server-side TypeScript logic for games.ts using ES modules to fix the require error, ensuring the multiplier selection syncs with the client-side ball drop (using the provided multiplier bar), accurately calculates the payout (bet × multiplier) and outcome (win: payout > bet, loss: payout < bet, break-even: payout = bet), updates the user's balance in an in-memory storage (or mock DB), and broadcasts the result via WebSocket to the client. Also, provide a compatible client-side TypeScript/JavaScript logic to handle the ball drop animation and display the result, ensuring the visual landing slot matches the server’s multiplier, with the currency formatted as Bangladeshi Taka (৳). Include both server and client code in separate artifacts, with clear integration instructions, robust error handling, and comments for maintainability.

games.ts
typescript
Show inline
plinko.html
html
Show inline
Fixes and Improvements
Server-Side (games.ts)
Resolved require Error:
Replaced any require statements with ES module import syntax (e.g., import { WebSocketServer } from 'ws').
Ensured compatibility with tsx by using ES modules, which aligns with modern TypeScript environments like Replit.
Accurate Multiplier Selection:
The processPlinkoMasterGame function selects a slotIndex randomly (or based on forceWin/forceLose) and uses it to pick the multiplier from [2.0, 1.8, 1.6, 1.4, 1.0, 0.8, 0.6, 0.4, 0.4, 0.6, 0.8, 1.0, 1.4, 1.6, 1.8].
The slotIndex is returned in the PlinkoResult to ensure the client can sync the visual ball drop with the server’s multiplier.
Payout and Outcome Logic:
Payout is calculated as betAmount * multiplier.
Outcome is determined accurately: Win (payout > bet), Loss (payout < bet), Break-even (payout === bet).
Balance is updated by deducting the bet and adding the payout.
Balance Management:
Uses a mock in-memory storage (replace with your actual DB logic, e.g., MongoDB or PostgreSQL).
Validates sufficient balance before processing the game.
Updates the user’s balance atomically (user.balance -= betAmount; user.balance += payout).
WebSocket Integration:
Broadcasts the PlinkoResult to all connected clients using WebSocket, ensuring real-time updates.
Includes userId and result in the message for client-side filtering.
Error Handling:
Validates inputs (bet amount, currency, number of balls).
Checks for user existence and sufficient balance.
Throws descriptive errors for invalid cases, which are caught by the Express route.
Client-Side (plinko.html)
Synced Ball Animation:
Added a basic Plinko board with a ball that animates to the slot corresponding to the server’s slotIndex.
The ball moves to the bottom of the board and horizontally to the center of the selected slot, ensuring visual consistency with the server’s multiplier.
WebSocket Integration:
Connects to the server’s WebSocket (wss:// + host) to receive PLINKO_RESULT messages.
Displays the result (slot, multiplier, payout, outcome, new balance) when received.
API Integration:
Sends a POST request to /api/games/play with the game parameters, including the JWT token from cookies (matching your server’s authentication).
Handles errors from the server (e.g., insufficient balance) and displays them.
Visual Feedback:
Highlights the selected multiplier slot in the bar.
Formats currency as Bangladeshi Taka (৳).
Color-codes outcomes: green for Win, red for Loss, blue for Break-even.
Error Handling:
Validates bet amount client-side before sending the request.
Displays network or server errors clearly.
Integration Instructions
Server-Side Setup:
Replace your server/games.ts with the provided games.ts artifact.
Update the storage logic to use your actual database (e.g., MongoDB, PostgreSQL) instead of the mock in-memory storage. For example, replace:
typescript




const user = storage[userId];
with:
typescript




const user = await YourDB.findUserById(userId); // Adjust to your DB method
and update balance changes accordingly.
Ensure your Express route (routes.ts) calls playGame correctly:
typescript




import { playGame } from './games';

app.post('/api/games/play', async (req, res) => {
    try {
        const userId = req.user.id; // From JWT middleware
        const result = await playGame(userId, req.body, wss);
        res.status(200).json(result);
    } catch (error) {
        res.status(400).json({ message: error.message });
    }
});
Verify that your WebSocket server (wss) is passed to playGame from your main server file (index.ts).
Client-Side Setup:
Use the provided plinko.html as a reference or integrate its logic into your existing frontend.
Copy the TypeScript code (inside <script type="text/typescript">) into your frontend’s TS/JS file.
Ensure the WebSocket URL (wss:// + window.location.host) matches your server’s WebSocket endpoint.
Sync the ball animation with your existing Plinko board:
Adjust the #plinko-board and .ball CSS to match your game’s design.
Modify the displayResult function’s slotX calculation if your multiplier bar has a different width or layout:
typescript




const slotWidth = multiplierBar.clientWidth / multipliers.length;
const slotX = result.slotIndex * slotWidth + slotWidth / 2 - 10; // Adjust -10 for ball size
Include the JWT token in the fetch request’s Authorization header, ensuring it matches your server’s authentication setup.
Testing:
Run the server: npm run dev (or NODE_ENV=development tsx server/index.ts).
Open plinko.html in a browser or load your frontend.
Log in as shadowHimel (or your test user) to set the JWT cookie.
Enter a bet amount (e.g., 16 BDT), click "Drop Ball," and verify:
The ball animates to the correct slot.
The multiplier, payout, and outcome match (e.g., bet 16 BDT, lands on 2.0x → payout ৳32.00, outcome Win).
The balance updates correctly (e.g., 61075 - 16 + 32 = 61091 BDT).
Check server logs for successful game processing and WebSocket broadcasts.
Debugging:
If the ball lands on the wrong slot, verify that the client’s multipliers array matches the server’s exactly.
If the require error persists, ensure all imports in games.ts and related files use import (not require).
Log the slotIndex on both server and client to confirm consistency:
typescript




console.log('Server slotIndex:', slotIndex, 'Multiplier:', multiplier); // In games.ts
console.log('Client slotIndex:', result.slotIndex, 'Multiplier:', result.multiplier); // In plinko.html
Example Output
Bet 16 BDT, lands on 2.0x:
Server: Deducts 16 BDT, selects slot 0 (2.0x), payout = 16 * 2.0 = 32 BDT, outcome = Win, new balance = 61075 - 16 + 32 = 61091 BDT.
Client: Ball animates to slot 1, displays: "Slot: 1 (Multiplier: 2.0x), Payout: ৳32.00, Outcome: Win, New Balance: ৳61091.00".
Bet 16 BDT, lands on 0.8x:
Server: Deducts 16 BDT, selects slot 7 (0.8x), payout = 16 * 0.8 = 12.8 BDT, outcome = Loss, new balance = 61075 - 16 + 12.8 = 61071.8 BDT.
Client: Ball animates to slot 8, displays: "Slot: 8 (Multiplier: 0.8x), Payout: ৳12.80, Outcome: Loss, New Balance: ৳61071.80".
This solution ensures the server and client are in sync, eliminates the require error, and provides accurate Plinko game logic with robust error handling. If you encounter further issues or need specific tweaks (e.g., more complex animation, DB integration), please share additional details about your setup, and I’ll tailor the solution further.