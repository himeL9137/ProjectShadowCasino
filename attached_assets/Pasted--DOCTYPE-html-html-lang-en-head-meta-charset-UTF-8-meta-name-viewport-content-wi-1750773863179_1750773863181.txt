<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plinko Game</title>
  <!-- p5.js library for drawing and animation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <!-- js-sha256 library for cryptographic hashing (for provably fair logic) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>
  <!-- Tone.js library for generating interactive audio -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <style>
    /* Global body styling */
    body {
      font-family: Arial, sans-serif;
      display: flex;
      background-color: #000000; /* Changed to black */
      margin: 0;
      padding: 20px;
      justify-content: center; /* Center content horizontally */
      align-items: flex-start; /* Align content to the top */
      min-height: 100vh; /* Ensure body takes full viewport height */
      color: #ffffff; /* White text for readability */
      overflow-x: hidden; /* Prevent horizontal scrolling */
    }

    /* Styles for the control panel */
    #controls {
      width: 280px; /* Increased width for controls */
      background-color: #1a1a1a; /* Darker grey for controls background */
      padding: 20px; /* More padding */
      border-radius: 12px; /* More rounded corners */
      color: #fff;
      margin-right: 30px; /* Increased margin to the right of controls */
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5); /* Stronger shadow for depth */
      display: flex;
      flex-direction: column;
      gap: 15px; /* Spacing between control elements */
    }

    /* Styling for labels, inputs, and buttons within controls */
    #controls label,
    #controls input,
    #controls button {
      display: block;
      width: 100%;
      box-sizing: border-box;
      font-size: 1em; /* Consistent font size */
    }

    /* Styling for input fields (bet amount) */
    #controls input,
    #controls select {
      background-color: #333333; /* Grey for input fields */
      color: #fff;
      border: 1px solid #666666; /* Lighter grey border */
      padding: 10px; /* Generous padding for input fields */
      border-radius: 8px; /* Rounded corners for inputs */
      outline: none; /* Remove default outline */
      transition: border-color 0.2s, box-shadow 0.2s; /* Smooth transition on focus */
    }

    #controls input:focus {
      border-color: #999999; /* Lighter grey on focus */
      box-shadow: 0 0 0 3px rgba(102, 102, 102, 0.4); /* Glow effect on focus */
    }

    /* General button styling */
    #controls button {
      background-color: #555555; /* Medium grey for buttons */
      color: #fff;
      border: none;
      padding: 12px; /* More padding for buttons */
      border-radius: 8px; /* Rounded corners for buttons */
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s; /* Add transform for button press effect */
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2); /* Subtle shadow for buttons */
    }

    #controls button:hover {
      background-color: #777777; /* Lighter grey on hover */
      transform: translateY(-2px); /* Slight lift on hover */
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3); /* Enhanced shadow on hover */
    }

    #controls button:active {
      transform: translateY(1px); /* Press effect */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Reduced shadow on active */
    }

    /* Specific styling for the Bet button */
    #controls button#betButton {
      background-color: #444444; /* Dark grey for the primary action button */
      font-weight: bold;
      font-size: 1.2em; /* Larger font for bet button */
      letter-spacing: 0.5px; /* Slight letter spacing */
    }

    #controls button#betButton:hover {
      background-color: #666666; /* Lighter grey on hover */
    }

    /* Styling for balance, probability, and result displays */
    #balance,
    #probability,
    #result {
      font-size: 1.1em; /* Slightly larger font */
      color: #cccccc; /* Light grey for information text */
      margin-top: 10px;
      padding: 10px;
      background-color: #333333; /* Matches input background for consistency */
      border-radius: 8px; /* Rounded corners */
      text-align: center;
      box-shadow: inset 0 1px 3px rgba(102, 102, 102, 0.2); /* Inner shadow for a recessed look */
    }

    /* Container for the p5.js canvas */
    #canvasContainer {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      max-width: 650px; /* Slightly increased max-width for canvas container */
      min-width: 300px; /* Ensure minimum width for canvas on smaller screens */
      aspect-ratio: 1 / 1; /* Maintain a 1:1 aspect ratio for the container */
    }

    /* Styling for the p5.js canvas */
    canvas {
      display: block;
      border-radius: 12px; /* More rounded corners for canvas */
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6); /* Stronger, deeper shadow for canvas */
      background-color: #1a1a1a; /* Darker grey for canvas */
      width: 100% !important; /* Ensure canvas takes full width of its container */
      height: 100% !important; /* Ensure canvas takes full height of its container */
    }

    /* Notification message box styling */
    .notification {
      position: fixed; /* Use fixed for notifications to float over content */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%); /* Center the notification */
      background-color: rgba(0, 0, 0, 0.9); /* Dark overlay */
      color: #fff;
      padding: 25px 40px; /* Increased padding */
      border-radius: 10px; /* More rounded corners */
      display: none; /* Hidden by default, controlled by JS */
      z-index: 1000; /* High z-index to ensure visibility */
      text-align: center;
      font-size: 1.4em; /* Larger font for notifications */
      font-weight: bold;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.8); /* More prominent shadow */
      animation: fadeInOut 2.5s forwards; /* Animation for showing/hiding */
    }

    /* Keyframes for the notification fade animation */
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    }

    /* Responsive adjustments for smaller screens (e.g., mobile) */
    @media (max-width: 768px) {
      body {
        flex-direction: column; /* Stack controls and canvas vertically */
        align-items: center; /* Center items when stacked */
        padding: 15px; /* Slightly reduced padding */
      }
      #controls {
        width: 95%; /* Take more width on smaller screens */
        margin-right: 0; /* Remove right margin */
        margin-bottom: 25px; /* Add space below controls */
        padding: 15px; /* Adjust padding for smaller screens */
      }
      #canvasContainer {
        width: 100%; /* Canvas container takes full width */
        max-width: 95%; /* Limit overall width to prevent stretching */
      }
      #controls button,
      #controls input {
        font-size: 0.95em; /* Slightly smaller font for controls on mobile */
        padding: 10px;
      }
      .notification {
        font-size: 1.1em; /* Adjust notification font size for mobile */
        padding: 15px 25px;
      }
    }
  </style>
</head>
<body>
  <!-- Control panel for game interactions -->
  <div id="controls">
    <label for="bet">Bet Amount ($):</label>
    <input type="number" id="bet" min="0.01" step="0.01" value="1">
    <button id="betButton" onclick="dropBall()">Bet</button>
    <div id="balance">Balance: $100.00</div>
    <div id="probability">Click a slot to see probability</div>
    <div id="result"></div>
  </div>
  <!-- Container for the p5.js canvas -->
  <div id="canvasContainer"></div>
  <!-- Notification message box (hidden by default) -->
  <div id="notification" class="notification"></div>

  <script>
    // --- Global Game Variables ---
    let pins = []; // Array to store pin objects
    let balls = []; // Array to store active ball objects
    let slots = []; // Array to store slot objects at the bottom
    const rows = 15; // Number of rows of pins in the Plinko board (determines pin structure)
    let balance = 100; // Player's current balance
    let betAmount = 1; // Current bet amount
    let clientSeed = generateSeed(); // Client-generated seed for provably fair system
    let serverSeed = generateSeed(); // Server-generated seed (simulated)
    let nonce = 0; // Incremental value for provably fair system

    // Constants for game physics and drawing (scaled dynamically based on canvas size)
    const pinSpacingBase = 30; // Base spacing between pins
    const slotWidthBase = 30; // Base width of the landing slots
    const ballRadiusBase = 5; // Base radius of the ball
    const pinRadiusBase = 4; // Base radius of the pins
    const gravity = 0.5; // Gravity applied to the ball (adjusted for smoother simulation)
    const bounceFactor = -0.7; // Coefficient of restitution for bounces
    const friction = 0.98; // Friction applied to ball's horizontal movement
    const animationSpeed = 0.1; // Controls how quickly the slot returns to position after being hit

    // Fixed multipliers for each slot, using the user-provided exact values (17 slots, index 0-16)
    const fixedMultipliers = [
      2.0, 1.8, 1.6, 1.4, 1.0, 0.8, 0.6, 0.4, 0.4,
      0.4, 0.6, 0.8, 1.0, 1.4, 1.6, 1.8, 2.0
    ];

    // Indices for multipliers > 1.0 (winning slots)
    const winningSlotIndices = [0, 1, 2, 3, 13, 14, 15, 16];
    // Indices for multipliers <= 1.0 (losing/break-even slots)
    const losingSlotIndices = [4, 5, 6, 7, 8, 9, 10, 11, 12];
    // Indices for multipliers 0.8, 0.6, 0.4 (for rigging when balance is high)
    const riggedLosingSlotIndices = [5, 6, 7, 8, 9, 10];

    // Board boundaries calculated dynamically
    let boardLeft, boardRight;

    // Tone.js synths for various sound effects
    let landingSynth; // For ball landing in a slot
    let pinHitSynth;  // For ball hitting a pin
    let betClickSynth; // For clicking the bet button
    let winSound;     // For winning notification
    let lossSound;    // For losing notification

    // --- p5.js Setup Function ---
    function setup() {
      // Create canvas and attach it to the 'canvasContainer' div
      let canvas = createCanvas(600, 600); // Initial size, will be resized
      canvas.parent('canvasContainer');
      resizeCanvasToContainer(); // Perform initial resize to fit container
      window.addEventListener('resize', resizeCanvasToContainer); // Add event listener for window resize

      // Set color mode to HSB (Hue, Saturation, Brightness) for easier vibrant colors
      colorMode(HSB, 360, 100, 100);

      updateGame(); // Initialize pin and slot positions based on current canvas size

      // Listen for 'Space' key press to drop a ball
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') dropBall();
      });

      // Initialize Tone.js synths with specific audio properties
      landingSynth = new Tone.Synth({
        oscillator: { type: "sine" }, // Smooth sine wave
        envelope: { attack: 0.001, decay: 0.2, sustain: 0.1, release: 0.5 } // Quick attack, moderate decay
      }).toDestination(); // Route sound to default output

      pinHitSynth = new Tone.MembraneSynth({
        pitchDecay: 0.008, // Rapid pitch decay for a "thump" sound
        octaves: 2, // Range of notes
        envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 } // Very short percussive envelope
      }).toDestination();

      betClickSynth = new Tone.Synth({
        oscillator: { type: "triangle" }, // Triangle wave for a clean click
        envelope: { attack: 0.001, decay: 0.05, sustain: 0.01, release: 0.05 } // Short click sound
      }).toDestination();

      winSound = new Tone.Synth({
        oscillator: { type: "square" }, // Square wave for a clear, distinct win sound
        envelope: { attack: 0.001, decay: 0.3, sustain: 0.1, release: 0.8 } // Sustained sound for winning
      }).toDestination();

      lossSound = new Tone.Synth({
        oscillator: { type: "sawtooth" }, // Sawtooth wave for a harsher loss sound
        envelope: { attack: 0.001, decay: 0.4, sustain: 0.05, release: 0.7 } // Sustained sound for losing
      }).toDestination();

      // Log initial seeds for provable fairness verification
      console.log('Client Seed:', clientSeed);
      console.log('Server Seed:', serverSeed);
      console.log('Verify fairness by checking hash of clientSeed + serverSeed + nonce.');
    }

    // --- Canvas Resizing Function ---
    function resizeCanvasToContainer() {
      const container = document.getElementById('canvasContainer');
      // Set canvas dimensions to match container's width, maintaining 1:1 aspect ratio
      resizeCanvas(container.offsetWidth, container.offsetWidth);
      updateGame(); // Recalculate pin and slot positions after canvas resize
    }

    // --- Game Board Initialization/Update Function ---
    function updateGame() {
      betAmount = parseFloat(document.getElementById('bet').value); // Get current bet from input
      pins = []; // Clear existing pins
      slots = []; // Clear existing slots

      let startY = height * 0.15; // Starting Y position for the first row of pins (15% down from top)
      let startX = width / 2; // X position for the center of the board

      // Populate pins in a triangular (Plinko board) pattern
      for (let i = 0; i < rows; i++) {
        let numPins = i + 1; // Number of pins in the current row
        // Calculate Y position for the current row, scaled by canvas width to maintain proportions
        let y = startY + i * pinSpacingBase * (width / 600);
        // Calculate the starting X position for the first pin in the row to center it
        let rowStartX = startX - (numPins - 1) * pinSpacingBase * (width / 600) / 2;
        for (let j = 0; j < numPins; j++) {
          let x = rowStartX + j * pinSpacingBase * (width / 600);
          pins.push({ x, y }); // Add pin to the array
        }
      }

      // Calculate board boundaries based on the outermost pins in the bottom row
      let bottomRowPins = pins.filter(pin => pin.y === startY + (rows - 1) * pinSpacingBase * (width / 600));
      boardLeft = Math.min(...bottomRowPins.map(pin => pin.x)) - pinRadiusBase * (width / 600);
      boardRight = Math.max(...bottomRowPins.map(pin => pin.x)) + pinRadiusBase * (width / 600);

      // Dynamically set numSlots based on the length of fixedMultipliers
      let numSlots = fixedMultipliers.length;
      let slotY = startY + rows * pinSpacingBase * (width / 600) + ballRadiusBase * (width / 600) * 2; // Position slots below pins

      // Populate landing slots
      for (let i = 0; i < numSlots; i++) {
        let multiplier = fixedMultipliers[i] !== undefined ? fixedMultipliers[i] : 0.0;
        // Calculate X position for each slot to distribute them evenly
        let x = startX - (numSlots - 1) * slotWidthBase * (width / 600) / 2 + i * slotWidthBase * (width / 600);
        let probability = calculateProbability(i, numSlots); // Calculate theoretical probability for the slot
        
        // Map multiplier to a grayscale brightness value (0-100 for HSB brightness)
        let brightness = map(multiplier, 0.4, 2.0, 20, 80); // Range from dark grey to light grey
        let slotColor = color(0, 0, brightness); // HSB: Hue 0, Saturation 0 for grayscale

        // Add slot object with animation properties
        slots.push({ x, y: slotY, multiplier, probability, color: slotColor, animationOffset: 0, targetOffset: 0 });
      }
    }

    // This function is no longer used for dynamic color based on multiplier, as colors are set in updateGame.
    function getSlotColor(multiplier) {
      return color(0, 0, 100); // Default white color, if it were to be used.
    }

    // --- Drop Ball Function ---
    function dropBall() {
      // Resume Tone.js audio context if it's suspended (required for audio to play)
      if (Tone.context.state !== 'running') {
        Tone.context.resume();
      }

      betAmount = parseFloat(document.getElementById('bet').value); // Get the latest bet amount
      if (balance < betAmount) {
        showMessage('Insufficient balance!', 'info'); // Show error if balance is too low
        return;
      }

      // Deduct bet amount from balance immediately
      balance -= betAmount;
      updateBalance(); // Update displayed balance

      // Play bet click sound using Tone.now() for immediate scheduling
      betClickSynth.triggerAttackRelease("C5", "16n", Tone.now());

      // Create a new ball object for visual simulation
      let ball = {
        x: width / 2, // Start at the top center of the canvas
        y: 50,
        vx: random(-0.5, 0.5), // Small random initial horizontal velocity
        vy: 0, // Initial vertical velocity
        row: 0, // Track which row of pins the ball is currently interacting with
        // Generate a unique seed for this ball using client, server seeds, and nonce
        seed: generateHash(clientSeed, serverSeed, nonce++),
        ballColor: color(random(360), 100, 100) // Assign a random vibrant color to the ball (for contrast)
      };
      balls.push(ball); // Add the new ball to the active balls array
    }

    // --- Simulate Ball Path (Rigging/Outcome Determination) ---
    function simulateBallPath(seed, numSlots) {
      // Rigging logic: If balance is >= $150, force outcome to 0.8x, 0.6x, or 0.4x slots
      if (balance >= 150) {
        console.log("Rigging: Forcing loss to 0.8x, 0.6x, or 0.4x slots (balance >= $150)");
        // Select a random index from the specific rigged losing slots
        return random(riggedLosingSlotIndices);
      } else {
        // If balance is less than $150, use the original 50/50 chance logic
        let randomChance = random(); // Value between 0 and 1
        if (randomChance < 0.5) { // 50% chance to win
          console.log("Rigging: Fair chance - Win (balance < $150, 50% chance)");
          // Select a random index from the winning slots
          return random(winningSlotIndices);
        } else { // 50% chance to lose
          console.log("Rigging: Fair chance - Loss (balance < $150, 50% chance)");
          // Select a random index from the general losing slots (includes 1.0x)
          return random(losingSlotIndices);
        }
      }
    }

    // --- Calculate Theoretical Slot Probability ---
    function calculateProbability(slotIndex, numSlots) {
      let n = rows; // Number of rows (trials)
      let k = slotIndex; // Number of 'right' movements to reach this slot
      let p = 0.5; // Probability of moving right (50/50 chance at each pin)

      // Helper function to calculate binomial coefficient (nCk)
      let combinations = (n, k) => {
        if (k < 0 || k > n) return 0;
        if (k === 0 || k === n) return 1;
        if (k > n / 2) k = n - k; // Optimization: nCk = nC(n-k)
        let result = 1;
        for (let i = 1; i <= k; i++) {
          result = result * (n - i + 1) / i;
        }
        return result;
      };

      // Binomial Probability Formula: P(X=k) = nCk * p^k * (1-p)^(n-k)
      let probability = combinations(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
      return (probability * 100).toFixed(2); // Return as percentage, 2 decimal places
    }

    // --- Custom Message Box ---
    function showMessage(message, type = 'info') {
      let notification = document.getElementById('notification');
      notification.innerText = message; // Set message text

      // Set background color based on message type (using grayscale values)
      if (type === 'win') {
        notification.style.backgroundColor = 'rgba(70, 130, 180, 0.85)'; // SteelBlue for win (still a color for clear feedback)
      } else if (type === 'loss') {
        notification.style.backgroundColor = 'rgba(178, 34, 34, 0.85)'; // FireBrick for loss (still a color for clear feedback)
      } else {
        notification.style.backgroundColor = 'rgba(0, 0, 0, 0.9)'; // Darker black for info
      }

      notification.style.display = 'block'; // Show the notification
      notification.style.animation = 'none'; // Reset animation
      void notification.offsetWidth; // Trigger reflow for animation restart
      notification.style.animation = 'fadeInOut 2.5s forwards'; // Apply animation
    }

    // --- Show Result Function ---
    function showResult(payout, slotIndex) {
      let resultText;
      let messageType;
      if (fixedMultipliers[slotIndex] > 1.0) {
        resultText = `Win: $${payout.toFixed(2)}`;
        messageType = 'win';
        winSound.triggerAttackRelease("C6", "4n", Tone.now());
      } else if (fixedMultipliers[slotIndex] === 1.0) {
        resultText = `Break Even: $${payout.toFixed(2)}`;
        messageType = 'info';
      } else {
        resultText = `Loss: $${(betAmount - payout).toFixed(2)} (Payout: $${payout.toFixed(2)})`;
        messageType = 'loss';
        lossSound.triggerAttackRelease("C3", "4n", Tone.now());
      }
      document.getElementById('result').innerText = resultText; // Update result display
      showMessage(resultText, messageType); // Show result as a notification
    }

    // --- Payout Calculation Function ---
    function calculatePayout(bet, slotIndex) {
      const multiplier = fixedMultipliers[slotIndex];
      const payout = bet * multiplier;
      // Round to 2 decimal places to prevent floating-point inaccuracies
      return parseFloat(payout.toFixed(2));
    }

    // --- p5.js Draw Loop ---
    function draw() {
      background(0); // Solid black background, cleared each frame

      // Draw pins
      fill(255); // White color for pins
      noStroke(); // No outline for pins
      for (let pin of pins) {
        // Draw ellipse, scaling size by canvas width to maintain visual consistency
        ellipse(pin.x, pin.y, pinRadiusBase * 2 * (width / 600), pinRadiusBase * 2 * (width / 600));
      }

      // Draw slots and their multipliers with animation
      for (let i = 0; i < slots.length; i++) {
        let slot = slots[i];

        // Smoothly interpolate the slot's current animation offset towards its target offset
        slot.animationOffset = lerp(slot.animationOffset, slot.targetOffset, animationSpeed);

        fill(slot.color); // Use the grayscale color determined by updateGame
        // Draw the slot rectangle, applying the animation offset to its Y position and scaling
        rect(slot.x - slotWidthBase * (width / 600) / 2, slot.y + slot.animationOffset, slotWidthBase * (width / 600), 15 * (width / 600), 5); // Add 5px border-radius
        
        fill(255); // Set text color to white for readability
        textAlign(CENTER);
        textSize(10 * (width / 600)); // Scale text size based on canvas width
        let multiplierText = slot.multiplier !== undefined ? slot.multiplier.toFixed(1) : '0.0';
        // Draw the multiplier text below the slot, applying the animation offset
        text(multiplierText + 'x', slot.x, slot.y + 30 * (width / 600) + slot.animationOffset);

        // If the animation is almost complete, reset the target offset to 0 to make the slot return
        if (abs(slot.animationOffset - slot.targetOffset) < 0.1) {
          slot.targetOffset = 0;
        }
      }

      // Initialize a time offset for pin hits within this draw frame
      let pinHitCurrentOffset = 0;

      // Update and draw balls
      for (let i = balls.length - 1; i >= 0; i--) {
        let ball = balls[i];
        ball.vy += gravity; // Apply gravity to vertical velocity
        ball.vx *= friction; // Apply friction to horizontal velocity
        ball.x += ball.vx; // Update horizontal position
        ball.y += ball.vy; // Update vertical position

        // Scale ball radius for accurate collision detection and drawing
        const scaledBallRadius = ballRadiusBase * (width / 600);
        const scaledPinRadius = pinRadiusBase * (width / 600);

        // Constrain ball within board boundaries to simulate side walls
        if (ball.x < boardLeft + scaledBallRadius) {
          ball.x = boardLeft + scaledBallRadius;
          ball.vx *= bounceFactor; // Bounce off the left boundary
        } else if (ball.x > boardRight - scaledBallRadius) {
          ball.x = boardRight - scaledBallRadius;
          ball.vx *= bounceFactor; // Bounce off the right boundary
        }

        // Pin collision detection and bounce logic
        if (ball.row < rows) {
          for (let pin of pins) {
            let d = dist(ball.x, ball.y, pin.x, pin.y); // Distance between ball and pin
            let collisionThreshold = scaledBallRadius + scaledPinRadius; // Sum of their radii
            if (d < collisionThreshold) {
              // Collision detected:
              let angle = atan2(ball.y - pin.y, ball.x - pin.x); // Angle from pin to ball
              let overlap = collisionThreshold - d; // How much they overlap
              ball.x += cos(angle) * overlap; // Push ball out of pin
              ball.y += sin(angle) * overlap;

              let currentSpeed = sqrt(ball.vx * ball.vx + ball.vy * ball.vy); // Current speed
              // Calculate new direction by reflecting velocity vector
              let newDirection = angle + PI;
              ball.vx = cos(newDirection) * currentSpeed * bounceFactor;
              ball.vy = sin(newDirection) * currentSpeed * bounceFactor;
              ball.row++; // Increment row count (ball has passed another row of pins)

              // Play pin hit sound with a small, incrementing offset
              pinHitSynth.triggerAttackRelease("C2", "32n", Tone.context.currentTime + pinHitCurrentOffset);
              pinHitCurrentOffset += 0.005; // Increased increment for distinct start times
            }
          }
        }

        // Check for landing in a slot (bottom of the board)
        for (let j = 0; j < slots.length; j++) {
          let slot = slots[j];
          const scaledSlotWidth = slotWidthBase * (width / 600);

          // If the ball has passed the slot's top Y position and is horizontally within the slot's bounds
          if (ball.y > slot.y && abs(ball.x - slot.x) < scaledSlotWidth / 2) {
            // Ball has landed in this slot
            console.log("Ball landed in slot:", slot.multiplier + "x");

            // Use the visual landing slot for payout
            let slotIndex = j;
            
            // Calculate payout
            let payout = calculatePayout(betAmount, slotIndex);

            console.log("Balance before payout:", balance.toFixed(2));
            console.log("Slot Index:", slotIndex);
            console.log("Multiplier:", fixedMultipliers[slotIndex]);
            console.log("Calculated Payout:", payout.toFixed(2));

            balance += payout; // Add the calculated payout to the player's balance
            updateBalance(); // Update the displayed balance
            showResult(payout, slotIndex); // Show the result message and play win/loss sound

            console.log("Balance after payout:", balance.toFixed(2));

            // Trigger animation for the landed slot
            slot.targetOffset = 5 * (width / 600); // Move slot down slightly

            // Play landing sound
            landingSynth.triggerAttackRelease("C4", "8n", Tone.now());

            balls.splice(balls.indexOf(ball), 1); // Remove the ball from active balls array
            break; // Stop checking other slots, this ball has landed
          }
        }

        // Remove ball if it goes off screen (below the bottom of the canvas)
        if (ball.y > height) {
          balls.splice(i, 1);
        }

        // Draw ball using its assigned color
        fill(ball.ballColor);
        noStroke();
        ellipse(ball.x, ball.y, scaledBallRadius * 2, scaledBallRadius * 2); // Draw scaled ball
      }
    }

    // --- Mouse Press Event Handler ---
    function mousePressed() {
      // Resume Tone.js audio context on user interaction
      if (Tone.context.state !== 'running') {
        Tone.context.resume();
      }

      for (let slot of slots) {
        // Scale slot dimensions for accurate click detection
        const scaledSlotWidth = slotWidthBase * (width / 600);
        const scaledSlotHeight = 15 * (width / 600); // Height of the slot rectangle

        // Check if mouse click is within the bounds of a slot
        if (mouseX > slot.x - scaledSlotWidth / 2 &&
            mouseX < slot.x + scaledSlotWidth / 2 &&
            mouseY > slot.y &&
            mouseY <= slot.y + scaledSlotHeight) {
          let probabilityText = slot.probability !== undefined ? slot.probability : '0.00';
          let multiplierText = slot.multiplier !== undefined ? slot.multiplier.toFixed(1) : '0.0';
          // Update the probability display in the control panel
          document.getElementById('probability').innerText = `Slot ${multiplierText}x: ${probabilityText}%`;
          break; // Stop checking after finding the clicked slot
        }
      }
    }

    // --- Update Balance Display ---
    function updateBalance() {
      document.getElementById('balance').innerText = `Balance: $${balance.toFixed(2)}`;
    }

    // --- Seed Generation for Provably Fair System ---
    function generateSeed() {
      return Math.random().toString(36).substring(2, 15);
    }

    // --- Hash Function for Provably Fair System ---
    function generateHash(clientSeed, serverSeed, nonce) {
      return sha256(clientSeed + serverSeed + nonce);
    }
  </script>
</body>
</html>
