<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plinko Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      background-color: #1a2c42;
      margin: 0;
      padding: 20px;
      justify-content: center; /* Center content horizontally */
      align-items: flex-start; /* Align content to the top */
      min-height: 100vh; /* Ensure body takes full viewport height */
    }
    #controls {
      width: 200px;
      background-color: #0d1a2b;
      padding: 15px;
      border-radius: 10px;
      color: #fff;
      margin-right: 20px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Add shadow for depth */
    }
    #controls label, #controls input, #controls button {
      display: block;
      margin: 10px 0;
      width: 100%;
      box-sizing: border-box;
    }
    #controls input, #controls select {
      background-color: #1a2c42;
      color: #fff;
      border: 1px solid #3a506b;
      padding: 8px; /* Increase padding for better touch targets */
      border-radius: 5px;
    }
    #controls button {
      background-color: #3a506b;
      color: #fff;
      border: none;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s; /* Add transform for button press effect */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    #controls button:hover {
      background-color: #4a607b;
      transform: translateY(-1px); /* Slight lift on hover */
    }
    #controls button:active {
      transform: translateY(1px); /* Press effect */
    }
    #controls button#betButton {
      background-color: #28a745;
      font-weight: bold;
      font-size: 1.1em; /* Larger font for bet button */
    }
    #controls button#betButton:hover {
      background-color: #2cc058;
    }
    #balance, #probability, #result {
      font-size: 1em; /* Slightly larger font */
      color: #ccc;
      margin-top: 10px;
      padding: 5px;
      background-color: #1a2c42;
      border-radius: 5px;
    }
    #canvasContainer {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      max-width: 600px; /* Limit canvas container width */
    }
    canvas {
        display: block;
        border-radius: 10px; /* Rounded corners for canvas */
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* Stronger shadow for canvas */
        background-color: #0d1a2b; /* Darker background for canvas */
    }
    .notification {
      position: fixed; /* Use fixed for notifications */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%); /* Removed scaling for simpler animation */
      background-color: rgba(0, 0, 0, 0.85); /* Slightly darker overlay */
      color: #fff;
      padding: 20px 30px; /* More padding */
      border-radius: 8px;
      display: none; /* Controlled by JS directly */
      z-index: 1000; /* Higher z-index */
      text-align: center;
      font-size: 1.2em; /* Larger font for notifications */
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      /* Removed opacity and transition for simpler display */
    }


    /* Responsive adjustments */
    @media (max-width: 768px) {
      body {
        flex-direction: column; /* Stack controls and canvas vertically */
        align-items: center; /* Center items when stacked */
        padding: 10px;
      }
      #controls {
        width: 90%; /* Take more width on smaller screens */
        margin-right: 0;
        margin-bottom: 20px; /* Add space below controls */
      }
      #canvasContainer {
        width: 100%;
        max-width: none; /* Remove max-width on canvas container */
      }
      canvas {
        width: 100% !important; /* Ensure canvas takes full width */
        height: auto !important; /* Maintain aspect ratio */
      }
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="bet">Bet Amount ($):</label>
    <input type="number" id="bet" min="0.01" step="0.01" value="1">
    <button id="betButton" onclick="dropBall()">Bet</button>
    <div id="balance">Balance: $100.00</div>
    <div id="probability">Click a slot to see probability</div>
    <div id="result"></div>
  </div>
  <div id="canvasContainer"></div>
  <div id="notification" class="notification"></div>
  <script>
    let pins = [];
    let balls = [];
    let slots = [];
    // Removed particles array: let particles = [];
    const rows = 15;
    let balance = 100;
    let betAmount = 1;
    let clientSeed = generateSeed();
    let serverSeed = generateSeed();
    let nonce = 0;
    const pinSpacing = 30;
    const slotWidth = 30;
    const ballRadius = 5;
    const pinRadius = 4;
    const gravity = 3.1416 / 30;
    const bounceFactor = -0.7;
    const friction = 0.99;
    const animationSpeed = 0.1; // Controls how quickly the slot returns to position

    const fixedMultipliers = [2.0, 1.8, 1.6, 1.4, 1.0, 0.8, 0.6, 0.4, 0.4, 0.6, 0.8, 1.0, 1.4, 1.6, 1.8, 2.0];
    // Indices for multipliers <= 1.0 (used for fair loss chance)
    const losingSlotIndices = [4, 5, 6, 7, 8, 9, 10, 11];
    // Indices for multipliers > 1.0 (used for fair win chance)
    const winningSlotIndices = [0, 1, 2, 3, 12, 13, 14, 15];
    // Indices for multipliers 0.8, 0.6, 0.4 (for rigging when balance is high)
    const riggedLosingSlotIndices = [5, 6, 7, 8, 9, 10];


    // Define board boundaries
    let boardLeft, boardRight;

    // Tone.js synths for various sounds
    let landingSynth; // For ball landing in a slot
    let pinHitSynth;  // For ball hitting a pin
    let betClickSynth; // For clicking the bet button
    let winSound;     // For winning notification
    let lossSound;    // For losing notification

    // Removed Particle class definition


    function setup() {
      // Create canvas and make it responsive
      let canvas = createCanvas(600, 600);
      canvas.parent('canvasContainer');
      resizeCanvasToContainer(); // Initial resize
      window.addEventListener('resize', resizeCanvasToContainer); // Resize on window resize

      // Set color mode to HSB (Hue, Saturation, Brightness) for easier vibrant colors
      colorMode(HSB, 360, 100, 100);
      updateGame(); // Call updateGame once in setup
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') dropBall();
      });

      // Initialize Tone.js synths
      landingSynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 0.001, decay: 0.2, sustain: 0.1, release: 0.5, }
      }).toDestination();

      pinHitSynth = new Tone.MembraneSynth({
        pitchDecay: 0.008,
        octaves: 2,
        envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1, }
      }).toDestination();

      betClickSynth = new Tone.Synth({
        oscillator: { type: "triangle" },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0.01, release: 0.05, }
      }).toDestination();

      winSound = new Tone.Synth({
        oscillator: { type: "square" },
        envelope: { attack: 0.001, decay: 0.3, sustain: 0.1, release: 0.8, }
      }).toDestination();

      lossSound = new Tone.Synth({
        oscillator: { type: "sawtooth" },
        envelope: { attack: 0.001, decay: 0.4, sustain: 0.05, release: 0.7, }
      }).toDestination();
    }

    // Function to resize canvas to fit its container
    function resizeCanvasToContainer() {
      const container = document.getElementById('canvasContainer');
      resizeCanvas(container.offsetWidth, container.offsetWidth); // Keep aspect ratio 1:1
      updateGame(); // Recalculate pin and slot positions after resize
    }

    function updateGame() {
      betAmount = parseFloat(document.getElementById('bet').value);
      pins = [];
      slots = [];
      let startY = height * 0.15; // Start pins lower, relative to canvas height
      let startX = width / 2;
      for (let i = 0; i < rows; i++) {
        let numPins = i + 1;
        let y = startY + i * pinSpacing * (width / 600); // Scale pin spacing with canvas width
        for (let j = 0; j < numPins; j++) {
          let x = startX - (numPins - 1) * pinSpacing * (width / 600) / 2 + j * pinSpacing * (width / 600);
          pins.push({ x, y });
        }
      }
      // Calculate board boundaries based on the bottom row of pins
      let bottomRowPins = pins.filter(pin => pin.y === startY + (rows - 1) * pinSpacing * (width / 600));
      boardLeft = Math.min(...bottomRowPins.map(pin => pin.x)) - pinRadius * (width / 600);
      boardRight = Math.max(...bottomRowPins.map(pin => pin.x)) + pinRadius * (width / 600);

      let numSlots = rows + 1;
      let slotY = startY + rows * pinSpacing * (width / 600);
      for (let i = 0; i < numSlots; i++) {
        let multiplier = fixedMultipliers[i] !== undefined ? fixedMultipliers[i] : 0.0;
        let x = startX - (numSlots - 1) * slotWidth * (width / 600) / 2 + i * slotWidth * (width / 600);
        let probability = calculateProbability(i, numSlots);
        let color = getSlotColor(multiplier);
        // Add animation properties to each slot
        slots.push({ x, y: slotY, multiplier, probability, color, animationOffset: 0, targetOffset: 0 });
      }
    }

    function getSlotColor(multiplier) {
      // Using HSB for slot colors as well for consistency, mapping multiplier to hue
      // Hue ranges from 0 (red) to 120 (green)
      let hue = map(multiplier, 0.4, 2.0, 0, 120);
      // Ensure hue stays within the 0-120 range
      hue = constrain(hue, 0, 120);
      // Saturation and brightness can be adjusted for desired depth
      let saturation = 80; // High saturation for vibrant colors
      let brightness = 90; // Relatively high brightness
      return color(hue, saturation, brightness);
    }

    function dropBall() {
      // Start Tone.js audio context on user interaction if not running
      if (Tone.context.state !== 'running') {
        Tone.context.resume();
      }

      betAmount = parseFloat(document.getElementById('bet').value); // Ensure betAmount is up-to-date
      if (balance < betAmount) {
        showMessage('Insufficient balance!', 'info'); // Use custom message box
        return;
      }
      // Deduct bet amount when the ball is dropped
      balance -= betAmount;
      updateBalance();

      // Play bet click sound with a small offset to ensure strict ordering
      betClickSynth.triggerAttackRelease("C5", "16n", Tone.context.currentTime + 0.01);


      // Create the ball for visual simulation
      let ball = {
        x: width / 2,
        y: 50,
        vx: random(-1, 1),
        vy: 0,
        row: 0,
        seed: generateHash(clientSeed, serverSeed, nonce++),
        // Assign a random vibrant color using HSB
        ballColor: color(random(360), 100, 100)
      };
      balls.push(ball);

      // The payout calculation and result display will happen when the ball lands in the draw loop
    }

    // This function determines the payout outcome based on rigging logic
    function simulateBallPath(seed, numSlots) {
      // Rigging logic: If balance is >= $150, force outcome to 0.8x, 0.6x, or 0.4x slots
      if (balance >= 150) {
        console.log("Rigging: Forcing loss to 0.8x, 0.6x, or 0.4x slots (balance >= $150)");
        // Select a random index from the specific rigged losing slots
        return random(riggedLosingSlotIndices);
      } else {
        // If balance is less than $150, use the original 50/50 chance logic
        let randomChance = random(); // Value between 0 and 1
        if (randomChance < 0.5) { // 50% chance to win
          console.log("Rigging: Fair chance - Win (balance < $150, 50% chance)");
          // Select a random index from the winning slots
          return random(winningSlotIndices);
        } else { // 50% chance to lose
          console.log("Rigging: Fair chance - Loss (balance < $150, 50% chance)");
          // Select a random index from the general losing slots (includes 1.0x)
          return random(losingSlotIndices);
        }
      }
    }

    function calculateProbability(slotIndex, numSlots) {
      let n = rows;
      let k = slotIndex;
      let p = 0.5;
      let combinations = (n, k) => {
        if (k < 0 || k > n) return 0;
        if (k === 0 || k === n) return 1;
        if (k > n / 2) k = n - k;
        let result = 1;
        for (let i = 1; i <= k; i++) {
          result = result * (n - i + 1) / i;
        }
        return result;
      };
      let probability = combinations(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
      return (probability * 100).toFixed(2);
    }

    // Custom message box function (reverted to simpler display)
    function showMessage(message, type = 'info') { // type can be 'info', 'win', 'loss'
      let notification = document.getElementById('notification');
      notification.innerText = message;

      // Set background color based on type
      if (type === 'win') {
        notification.style.backgroundColor = 'rgba(40, 167, 69, 0.85)'; // Green for win
      } else if (type === 'loss') {
        notification.style.backgroundColor = 'rgba(220, 53, 69, 0.85)'; // Red for loss
      } else {
        notification.style.backgroundColor = 'rgba(0, 0, 0, 0.85)'; // Default black for info
      }

      notification.style.display = 'block'; // Directly show
      setTimeout(() => {
        notification.style.display = 'none'; // Directly hide after timeout
      }, 2000);
    }

    function showResult(payout) {
      let resultText;
      let messageType;
      if (payout >= betAmount) {
        resultText = `Win: $${(payout - betAmount).toFixed(2)} (Total: $${payout.toFixed(2)})`;
        messageType = 'win';
        winSound.triggerAttackRelease("C6", "4n", Tone.context.currentTime + 0.01); // Play win sound with a small offset
      } else {
        resultText = `Loss: $${betAmount.toFixed(2)}`;
        messageType = 'loss';
        lossSound.triggerAttackRelease("C3", "4n", Tone.context.currentTime + 0.01); // Play loss sound with a small offset
      }
      document.getElementById('result').innerText = resultText;
      showMessage(resultText, messageType); // Use custom message box for results
    }

    function draw() {
      background(0); // Solid black background to ensure canvas clears

      // Draw pins
      fill(255); // White color for pins
      for (let pin of pins) {
        ellipse(pin.x, pin.y, pinRadius * 2 * (width / 600), pinRadius * 2 * (width / 600)); // Scale pin size
      }

      // Draw slots and multipliers with animation
      for (let i = 0; i < slots.length; i++) {
        let slot = slots[i];

        // Smoothly move the slot towards its target offset
        slot.animationOffset = lerp(slot.animationOffset, slot.targetOffset, animationSpeed);

        fill(slot.color); // Use the color determined by getSlotColor
        // Apply the animation offset to the y position and scale slot size
        rect(slot.x - slotWidth * (width / 600) / 2, slot.y + slot.animationOffset, slotWidth * (width / 600), 15 * (width / 600));
        fill(255); // Set text color to white for readability
        textAlign(CENTER);
        textSize(10 * (width / 600)); // Scale text size
        let multiplierText = slot.multiplier !== undefined ? slot.multiplier.toFixed(1) : '0.0';
        // Apply the animation offset to the y position of the text
        text(multiplierText + 'x', slot.x, slot.y + 30 * (width / 600) + slot.animationOffset);

        // Reset target offset if animation is almost complete
        if (abs(slot.animationOffset - slot.targetOffset) < 0.1) {
            slot.targetOffset = 0;
        }
      }

      // Re-initialize a time offset for pin hits within this draw frame
      // This ensures each pin hit sound has a unique start time, preventing Tone.js errors.
      let pinHitCurrentOffset = 0;

      // Update and draw balls
      for (let i = balls.length - 1; i >= 0; i--) {
        let ball = balls[i];
        ball.vy += gravity;
        ball.vx *= friction;
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Scale ball radius for collision detection and drawing
        const scaledBallRadius = ballRadius * (width / 600);

        // Constrain ball within board boundaries
        if (ball.x < boardLeft + scaledBallRadius) {
          ball.x = boardLeft + scaledBallRadius;
          ball.vx *= bounceFactor; // Bounce off left boundary
        } else if (ball.x > boardRight - scaledBallRadius) {
          ball.x = boardRight - scaledBallRadius;
          ball.vx *= bounceFactor; // Bounce off right boundary
        }

        // Pin collision detection and bounce
        if (ball.row < rows) {
          for (let pin of pins) {
            let d = dist(ball.x, ball.y, pin.x, pin.y);
            let collisionThreshold = scaledBallRadius + pinRadius * (width / 600); // Scale pin radius for collision
            if (d < collisionThreshold) {
              let angle = atan2(ball.y - pin.y, ball.x - pin.x);
              let overlap = collisionThreshold - d;
              ball.x += cos(angle) * overlap;
              ball.y += sin(angle) * overlap;
              let currentSpeed = sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
              let newDirection = angle + PI;
              ball.vx = cos(newDirection) * currentSpeed * bounceFactor;
              ball.vy = sin(newDirection) * currentSpeed * bounceFactor;
              ball.row++;

              // Play pin hit sound with a small, incrementing offset
              // The offset is increased for each hit within the same frame to ensure unique start times.
              pinHitSynth.triggerAttackRelease("C2", "32n", Tone.context.currentTime + pinHitCurrentOffset);
              pinHitCurrentOffset += 0.001; // Increased increment to ensure distinct start times

              // Removed particle generation on pin collision
              // for (let p = 0; p < 5; p++) {
              //     particles.push(new Particle(ball.x, ball.y, ball.ballColor));
              // }
            }
          }
        }

        // Check for landing in a slot
        for (let i = 0; i < slots.length; i++) { // Iterate through slots to find the landing one
            let slot = slots[i];
            // Scale slot width for collision detection
            const scaledSlotWidth = slotWidth * (width / 600);
            if (ball.y > slot.y && abs(ball.x - slot.x) < scaledSlotWidth / 2) {
                // Ball has landed in this slot!
                console.log("Ball visually landed in slot:", slot.multiplier + "x"); // Log visual landing slot

                // Calculate the payout using the rigged logic based on the *simulated* path
                let riggedSlotIndex = simulateBallPath(ball.seed, slots.length);
                let payout = betAmount * slots[riggedSlotIndex].multiplier;

                console.log("Balance before payout:", balance.toFixed(2)); // Log balance before payout
                console.log("Rigged Slot Index:", riggedSlotIndex); // Log rigged slot index
                console.log("Rigged Multiplier:", slots[riggedSlotIndex].multiplier); // Log rigged multiplier
                console.log("Calculated Payout:", payout.toFixed(2)); // Log calculated payout

                balance += payout; // Add payout to balance
                updateBalance(); // Update the displayed balance again after payout
                showResult(payout); // Show the result notification (which now plays win/loss sound)

                console.log("Balance after payout:", balance.toFixed(2)); // Log balance after payout


                // Trigger animation for the visually landed slot
                slot.targetOffset = 5 * (width / 600); // Set target offset to move down, scaled

                // Play landing sound with a small offset to ensure strict ordering
                landingSynth.triggerAttackRelease("C4", "8n", Tone.context.currentTime + 0.01);

                // Removed particle generation on slot landing
                // for (let p = 0; p < 20; p++) {
                //     particles.push(new Particle(ball.x, ball.y, ball.ballColor));
                // }

                balls.splice(balls.indexOf(ball), 1); // Remove the current ball
                break; // Only land in one slot
            }
        }


        // Remove ball if it goes off screen
        if (ball.y > height) {
          balls.splice(i, 1);
        }

        // Draw ball using its assigned color
        fill(ball.ballColor);
        ellipse(ball.x, ball.y, scaledBallRadius * 2, scaledBallRadius * 2); // Draw scaled ball
      }

      // Removed particle update and draw loop
      // for (let j = particles.length - 1; j >= 0; j--) {
      //     particles[j].update();
      //     particles[j].display();
      //     if (particles[j].isDead()) {
      //         particles.splice(j, 1);
      //     }
      // }
    }

    function mousePressed() {
      // Start Tone.js audio context on user interaction
      if (Tone.context.state !== 'running') {
        Tone.context.resume();
      }

      for (let slot of slots) {
        // Scale slot dimensions for click detection
        const scaledSlotWidth = slotWidth * (width / 600);
        const scaledSlotHeight = 15 * (width / 600);
        if (mouseX > slot.x - scaledSlotWidth / 2 && mouseX < slot.x + scaledSlotWidth / 2 && mouseY > slot.y && mouseY < slot.y + scaledSlotHeight) {
          let probabilityText = slot.probability !== undefined ? slot.probability : '0.00';
          let multiplierText = slot.multiplier !== undefined ? slot.multiplier.toFixed(1) : '0.0';
          document.getElementById('probability').innerText = `Slot ${multiplierText}x: ${probabilityText}%`;
          break;
        }
      }
    }

    function updateBalance() {
      document.getElementById('balance').innerText = `Balance: $${balance.toFixed(2)}`;
    }

    function generateSeed() {
      return Math.random().toString(36).substring(2, 15);
    }

    function generateHash(clientSeed, serverSeed, nonce) {
      return sha256(clientSeed + serverSeed + nonce);
    }

    console.log('Client Seed:', clientSeed);
    console.log('Server Seed:', serverSeed);
    console.log('Verify fairness by checking hash of clientSeed + serverSeed + nonce.');
  </script>
</body>
</html>
