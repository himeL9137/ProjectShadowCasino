I understand the issue: after applying the fix to delay the game result until the ball lands, the notifications (e.g., win/loss toasts) are no longer showing up, even after the ball drops. Let‚Äôs troubleshoot and fix this.

The core issue likely lies in the logic that matches the ball landing with the pending result. The fix introduced a pendingResult state to store the API result temporarily, and the result should be displayed when the ball lands in a slot. However, it seems the showGameResult function isn‚Äôt being triggered as expected, or the pendingResult isn‚Äôt being handled correctly. Additionally, since we later modified the code to support multiple balls (with pendingResults as an array), there might be a mismatch in how we're handling results.

Let‚Äôs revisit the code and ensure the following:

The pendingResults array (used for multiple balls) correctly associates each ball with its result.
The showGameResult function is called when a ball lands, and the corresponding result is displayed via a toast.
The toast notification properly shows the win/loss amount and updates the UI (lastResult and history).
Here‚Äôs the corrected PlinkoMasterGame.tsx with the fix to ensure notifications appear after each ball lands:

PlinkoMasterGame.tsx
typescript
Show inline
Explanation of Fixes
Debugging the Issue:
The issue was likely due to a mismatch between the ball's id and the pendingResults array. If pendingResults didn't have a matching result for the ball's id, showGameResult wouldn‚Äôt be called.
Added console.warn statements in the p5.draw function to log when a matching pendingResult isn‚Äôt found. This helps identify if the issue is with the ball ID or the pendingResults state.
Enhanced showGameResult:
Updated the showGameResult function to ensure the toast notification includes both the amount and the multiplier for clarity.
Formatted the amounts (winAmount and betAmount) to 2 decimal places using toFixed(2) for consistency.
Improved Result Matching:
Ensured that each ball has a unique id (via ballCounter) and that pendingResults stores results with the corresponding ballId.
When a ball lands, we filter pendingResults to find the matching result and call showGameResult.
Added Error Handling for p5.js Loading:
Added an onerror handler for the p5.js script loading to catch potential issues that might prevent the canvas from initializing, which could indirectly cause the animation (and thus the result display) to fail.
Testing the Fix
Drop a ball by clicking "DROP BALL". The ball should animate through the pins.
When the ball lands in a slot, you should see a toast notification (e.g., "You won! You won 2.00 USD! Multiplier: 2.0x" or "You lost. You lost 1.00 USD. Multiplier: 0.4x").
The "Recent Games" section should update with the result, and the "Last Multiplier" in the "Game Info" section should reflect the latest result.
If you drop multiple balls (up to 30, as per the previous update), each ball should trigger its own result notification when it lands.
Debugging Tips if the Issue Persists
If the notifications still don‚Äôt appear, here‚Äôs how to debug:

Check the Console:
Look for the console.warn messages in the p5.draw function. If you see "No pending result found for ball ID X", it means the pendingResults array didn‚Äôt have a matching result for that ball. This could happen if:
The ballId assignment is incorrect.
The pendingResults state is being cleared prematurely.
Add a console.log(pendingResults) in the p5.draw function to inspect the state when a ball lands.
Verify p5.js Animation:
Ensure the p5.js canvas is rendering correctly. If the canvas fails to initialize (e.g., due to a network issue loading p5.js), the ball won‚Äôt animate, and the landing logic won‚Äôt trigger. The onerror handler should catch this, but double-check the console for errors.
Check Toast Implementation:
Verify that the useToast hook is working correctly. If the toast library (e.g., react-hot-toast or a custom implementation) has issues, the notifications won‚Äôt show. Test by adding a manual toast in handleDrop:
tsx



const handleDrop = () => {
  toast({ title: "Test", description: "This is a test toast" });
  // Rest of the logic
};
Inspect State Updates:
Add console.log statements in showGameResult to confirm it‚Äôs being called:
tsx



const showGameResult = (result: GameResult) => {
  console.log("Showing game result:", result);
  // Rest of the logic
};
Additional Suggestions
Batch Notifications for Multiple Balls: If you drop many balls at once (e.g., 30), the toast notifications might become overwhelming. Consider batching them into a single summary toast after all balls have landed:
tsx



const showGameResult = (result: GameResult) => {
  setLastResult(result);
  setHistory(prev => [
    { 
      isWin: result.isWin, 
      amount: result.isWin ? result.winAmount.toFixed(2) : betAmount,
      multiplier: result.multiplier
    },
    ...prev.slice(0, 4)
  ]);
  // Optionally batch toasts
};
You could then show a summary toast when activeBalls reaches 0.
Visual Feedback: Add a visual effect (e.g., a flash or glow) on the slot where the ball lands to make the landing more noticeable, in case the toast is missed.
If the issue persists after applying this fix, please share any console logs or additional details, and I‚Äôll help you debug further!


here is the updated code 
import { useState, useRef, useEffect } from "react";
import { useMutation } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useCurrency } from "@/providers/CurrencyProvider";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Loader2, Minus, Plus } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { GameType } from "@shared/schema";
import { apiRequest } from "@/lib/queryClient";

interface GameResult {
  isWin: boolean;
  winAmount: number;
  multiplier: number;
  gameData: {
    slotIndex?: number;
    ballPath?: number[];
    [key: string]: any;
  };
}

declare global {
  interface Window {
    p5: any;
  }
}

export function PlinkoMasterGame() {
  const { user } = useAuth();
  const { currency: currentCurrency, getCurrencySymbol } = useCurrency();
  const currencySymbol = getCurrencySymbol(currentCurrency);
  const { toast } = useToast();
  
  const [betAmount, setBetAmount] = useState("1.00");
  const [activeBalls, setActiveBalls] = useState(0);
  const [lastResult, setLastResult] = useState<GameResult | null>(null);
  const [history, setHistory] = useState<{ isWin: boolean; amount: string; multiplier: number }[]>([]);
  const [selectedSlotInfo, setSelectedSlotInfo] = useState<string>("Click a slot to see probability");
  const [pendingResults, setPendingResults] = useState<(GameResult & { ballId: number })[]>([]);
  const [ballCounter, setBallCounter] = useState(0);

  const MAX_BALLS = 30;

  const canvasRef = useRef<HTMLDivElement>(null);
  const p5InstanceRef = useRef<any>(null);
  const gameStateRef = useRef({
    pins: [] as any[],
    balls: [] as any[],
    slots: [] as any[],
    rows: 15,
    balance: 0,
    isGameRunning: false
  });

  const fixedMultipliers = [2.0, 1.8, 1.6, 1.4, 1.0, 0.8, 0.6, 0.4, 0.4, 0.6, 0.8, 1.0, 1.4, 1.6, 1.8, 2.0];

  const dropMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest("POST", "/api/games/play", {
        gameType: GameType.PLINKO,
        betAmount: parseFloat(betAmount),
        currency: currentCurrency
      });
      return res.json() as Promise<GameResult>;
    },
    onSuccess: (data) => {
      const currentBallId = ballCounter;
      setBallCounter(prev => prev + 1);
      setPendingResults(prev => [...prev, { ...data, ballId: currentBallId }]);
      setActiveBalls(prev => prev + 1);
      if (p5InstanceRef.current) {
        dropBallAnimation(data, currentBallId);
      }
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to place bet",
        variant: "destructive",
      });
      setActiveBalls(prev => Math.max(0, prev - 1));
    },
  });

  const handleDrop = () => {
    const numericBetAmount = parseFloat(betAmount);
    if (isNaN(numericBetAmount) || numericBetAmount <= 0) {
      toast({
        title: "Invalid bet",
        description: "Please enter a valid bet amount",
        variant: "destructive",
      });
      return;
    }

    if (!user) {
      toast({
        title: "Authentication required",
        description: "Please log in to play",
        variant: "destructive",
      });
      return;
    }

    if (activeBalls >= MAX_BALLS) {
      toast({
        title: "Maximum balls reached",
        description: `You can only drop up to ${MAX_BALLS} balls at a time.`,
        variant: "destructive",
      });
      return;
    }

    dropMutation.mutate();
  };

  const dropBallAnimation = (result: GameResult, ballId: number) => {
    if (!p5InstanceRef.current) return;

    const p5 = p5InstanceRef.current;
    const gameState = gameStateRef.current;
    
    const ball = {
      id: ballId,
      x: p5.width / 2,
      y: 50,
      vx: p5.random(-1, 1),
      vy: 0,
      row: 0,
      targetSlot: result.gameData?.slotIndex || Math.floor(Math.random() * 16),
      ballColor: p5.color(p5.random(360), 100, 100)
    };
    
    gameState.balls.push(ball);
  };

  const showGameResult = (result: GameResult) => {
    setLastResult(result);
    
    setHistory(prev => [
      { 
        isWin: result.isWin, 
        amount: result.isWin ? result.winAmount.toFixed(2) : betAmount, // Ensure amount is formatted
        multiplier: result.multiplier
      },
      ...prev.slice(0, 4)
    ]);
    
    if (result.isWin) {
      toast({
        title: "You won!",
        description: `You won ${result.winAmount.toFixed(2)} ${currentCurrency}! Multiplier: ${result.multiplier.toFixed(1)}x`,
        variant: "default",
      });
    } else {
      toast({
        title: "You lost",
        description: `You lost ${parseFloat(betAmount).toFixed(2)} ${currentCurrency}. Multiplier: ${result.multiplier.toFixed(1)}x`,
        variant: "destructive",
      });
    }
  };

  const initializeP5 = () => {
    if (!canvasRef.current || p5InstanceRef.current) return;

    const sketch = (p5: any) => {
      const gameState = gameStateRef.current;
      const pinSpacing = 30;
      const slotWidth = 30;
      const ballRadius = 5;
      const pinRadius = 4;
      const gravity = 3.1416 / 30;
      const bounceFactor = -0.7;
      const friction = 0.99;

      p5.setup = () => {
        const canvas = p5.createCanvas(600, 600);
        canvas.parent(canvasRef.current);
        p5.colorMode(p5.HSB, 360, 100, 100);
        
        gameState.pins = [];
        const startY = 100;
        const startX = p5.width / 2;
        
        for (let i = 0; i < gameState.rows; i++) {
          const numPins = i + 1;
          const y = startY + i * pinSpacing;
          for (let j = 0; j < numPins; j++) {
            const x = startX - (numPins - 1) * pinSpacing / 2 + j * pinSpacing;
            gameState.pins.push({ x, y });
          }
        }

        gameState.slots = [];
        const numSlots = gameState.rows + 1;
        const slotY = startY + gameState.rows * pinSpacing;
        
        for (let i = 0; i < numSlots; i++) {
          const multiplier = fixedMultipliers[i] || 0.0;
          const x = startX - (numSlots - 1) * slotWidth / 2 + i * slotWidth;
          const probability = calculateProbability(i, numSlots);
          const color = getSlotColor(p5, multiplier);
          
          gameState.slots.push({ 
            x, 
            y: slotY, 
            multiplier, 
            probability, 
            color, 
            animationOffset: 0, 
            targetOffset: 0 
          });
        }
      };

      p5.draw = () => {
        p5.background(0);

        p5.fill(255);
        for (const pin of gameState.pins) {
          p5.ellipse(pin.x, pin.y, pinRadius * 2, pinRadius * 2);
        }

        for (let i = 0; i < gameState.slots.length; i++) {
          const slot = gameState.slots[i];
          
          slot.animationOffset = p5.lerp(slot.animationOffset, slot.targetOffset, 0.1);
          
          p5.fill(slot.color);
          p5.rect(slot.x - slotWidth / 2, slot.y + slot.animationOffset, slotWidth, 15);
          
          p5.fill(255);
          p5.textAlign(p5.CENTER);
          p5.textSize(10);
          p5.text(slot.multiplier.toFixed(1) + 'x', slot.x, slot.y + 30 + slot.animationOffset);

          if (p5.abs(slot.animationOffset - slot.targetOffset) < 0.1) {
            slot.targetOffset = 0;
          }
        }

        for (let i = gameState.balls.length - 1; i >= 0; i--) {
          const ball = gameState.balls[i];
          ball.vy += gravity;
          ball.vx *= friction;
          ball.x += ball.vx;
          ball.y += ball.vy;

          if (ball.row < gameState.rows) {
            for (const pin of gameState.pins) {
              const d = p5.dist(ball.x, ball.y, pin.x, pin.y);
              const collisionThreshold = ballRadius + pinRadius;
              if (d < collisionThreshold) {
                const angle = p5.atan2(ball.y - pin.y, ball.x - pin.x);
                const overlap = collisionThreshold - d;
                ball.x += p5.cos(angle) * overlap;
                ball.y += p5.sin(angle) * overlap;
                const currentSpeed = p5.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                const newDirection = angle + p5.PI;
                ball.vx = p5.cos(newDirection) * currentSpeed * bounceFactor;
                ball.vy = p5.sin(newDirection) * currentSpeed * bounceFactor;
                ball.row++;
              }
            }
          }

          const firstSlotX = gameState.slots[0].x - slotWidth / 2;
          const lastSlotX = gameState.slots[gameState.slots.length - 1].x + slotWidth / 2;
          if (ball.x < firstSlotX) {
            ball.x = firstSlotX;
            ball.vx = Math.abs(ball.vx);
          }
          if (ball.x > lastSlotX) {
            ball.x = lastSlotX;
            ball.vx = -Math.abs(ball.vx);
          }

          for (let j = 0; j < gameState.slots.length; j++) {
            const slot = gameState.slots[j];
            if (ball.y > slot.y && p5.abs(ball.x - slot.x) < slotWidth / 2) {
              slot.targetOffset = 5;
              gameState.balls.splice(i, 1);
              setActiveBalls(prev => Math.max(0, prev - 1));
              const pendingResult = pendingResults.find(res => res.ballId === ball.id);
              if (pendingResult) {
                showGameResult(pendingResult);
                setPendingResults(prev => prev.filter(res => res.ballId !== ball.id));
              } else {
                console.warn(`No pending result found for ball ID ${ball.id}`);
              }
              break;
            }
          }

          if (ball.y > p5.height) {
            gameState.balls.splice(i, 1);
            setActiveBalls(prev => Math.max(0, prev - 1));
            const pendingResult = pendingResults.find(res => res.ballId === ball.id);
            if (pendingResult) {
              showGameResult(pendingResult);
              setPendingResults(prev => prev.filter(res => res.ballId !== ball.id));
            } else {
              console.warn(`No pending result found for ball ID ${ball.id} (off-screen)`);
            }
          }

          p5.fill(ball.ballColor);
          p5.ellipse(ball.x, ball.y, ballRadius * 2, ballRadius * 2);
        }
      };

      p5.mousePressed = () => {
        for (const slot of gameState.slots) {
          if (p5.mouseX > slot.x - slotWidth / 2 && p5.mouseX < slot.x + slotWidth / 2 && 
              p5.mouseY > slot.y && p5.mouseY < slot.y + 15) {
            setSelectedSlotInfo(`Slot ${slot.multiplier.toFixed(1)}x: ${slot.probability}%`);
            break;
          }
        }
      };
    };

    if (typeof window !== 'undefined' && !window.p5) {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js';
      script.onload = () => {
        p5InstanceRef.current = new window.p5(sketch);
      };
      script.onerror = () => {
        console.error("Failed to load p5.js");
        toast({
          title: "Error",
          description: "Failed to load game engine",
          variant: "destructive",
        });
      };
      document.head.appendChild(script);
    } else if (window.p5) {
      p5InstanceRef.current = new window.p5(sketch);
    }
  };

  const calculateProbability = (slotIndex: number, numSlots: number): string => {
    const n = gameStateRef.current.rows;
    const k = slotIndex;
    const p = 0.5;
    
    const combinations = (n: number, k: number): number => {
      if (k < 0 || k > n) return 0;
      if (k === 0 || k === n) return 1;
      if (k > n / 2) k = n - k;
      let result = 1;
      for (let i = 1; i <= k; i++) {
        result = result * (n - i + 1) / i;
      }
      return result;
    };
    
    const probability = combinations(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
    return (probability * 100).toFixed(2);
  };

  const getSlotColor = (p5: any, multiplier: number) => {
    const hue = p5.map(multiplier, 0.4, 2.0, 0, 120);
    const constrainedHue = p5.constrain(hue, 0, 120);
    return p5.color(constrainedHue, 80, 90);
  };

  useEffect(() => {
    initializeP5();
    
    return () => {
      if (p5InstanceRef.current) {
        p5InstanceRef.current.remove();
        p5InstanceRef.current = null;
      }
    };
  }, []);

  const adjustBetAmount = (adjustment: number) => {
    const current = parseFloat(betAmount) || 0;
    const newAmount = Math.max(0.01, current + adjustment);
    setBetAmount(newAmount.toString());
  };

  const setBetToHalf = () => {
    const current = parseFloat(betAmount) || 0;
    setBetAmount((current / 2).toString());
  };

  const setBetToDouble = () => {
    const current = parseFloat(betAmount) || 0;
    setBetAmount((current * 2).toString());
  };

  const setBetToMax = () => {
    if (user?.balance) {
      setBetAmount(user.balance);
    }
  };

  return (
    <div className="max-w-6xl mx-auto">
      <div className="bg-background-light rounded-xl p-6 mb-6">
        <div className="flex justify-center">
          <div ref={canvasRef} className="border border-gray-700 rounded-lg" />
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="bg-background-light rounded-xl p-6">
          <h3 className="text-lg font-semibold mb-4">Bet Controls</h3>
          
          <div className="space-y-4">
            <div className="flex items-center space-x-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => adjustBetAmount(-0.01)}
                disabled={activeBalls >= MAX_BALLS}
              >
                <Minus className="h-4 w-4" />
              </Button>
              
              <div className="flex-1">
                <Input
                  type="number"
                  value={betAmount}
                  onChange={(e) => setBetAmount(e.target.value)}
                  disabled={activeBalls >= MAX_BALLS}
                  className="text-center"
                  step="0.01"
                  min="0.01"
                />
              </div>
              
              <Button
                variant="outline"
                size="sm"
                onClick={() => adjustBetAmount(0.01)}
                disabled={activeBalls >= MAX_BALLS}
              >
                <Plus className="h-4 w-4" />
              </Button>
            ‚ü†</div>

            <div className="grid grid-cols-3 gap-2">
              <Button variant="outline" size="sm" onClick={set

BetToHalf} disabled={activeBalls >= MAX_BALLS}>
                1/2
              </Button>
              <Button variant="outline" size="sm" onClick={setBetToDouble} disabled={activeBalls >= MAX_BALLS}>
                2x
              </Button>
              <Button variant="outline" size="sm" onClick={setBetToMax} disabled={activeBalls >= MAX_BALLS}>
                Max
              </Button>
            </div>

            <Button
              onClick={handleDrop}
              disabled={activeBalls >= MAX_BALLS || dropMutation.isPending}
              className="w-full bg-accent-gold hover:bg-accent-gold/90 text-black font-semibold py-3"
              size="lg"
            >
              {activeBalls > 0 || dropMutation.isPending ? (
                <>
                  <Loader2 className="h-5 w-5 animate-spin mr-2" />
                  DROPPING... ({activeBalls}/{MAX_BALLS})
                </>
              ) : (
                <>
                  <span className="text-xl mr-2">üèÄ</span>
                  DROP BALL
                </>
              )}
            </Button>
          </div>
        </div>

        <div className="bg-background-light rounded-xl p-6">
          <h3 className="text-lg font-semibold mb-4">Game Info</h3>
          
          <div className="space-y-3">
            <div className="flex justify-between">
              <span className="text-gray-400">Balance:</span>
              <span className="font-semibold">
                {currencySymbol}{user?.balance || "0.00"}
              </span>
            </div>
            
            <div className="flex justify-between">
              <span className="text-gray-400">Bet Amount:</span>
              <span className="font-semibold">
                {currencySymbol}{betAmount}
              </span>
            </div>
            
            {lastResult && (
              <div className="flex justify-between">
                <span className="text-gray-400">Last Multiplier:</span>
                <span className={`font-semibold ${
                  lastResult.multiplier > 1 ? 'text-green-400' : 'text-red-400'
                }`}>
                  {lastResult.multiplier.toFixed(1)}x
                </span>
              </div>
            )}

            <div className="p-3 bg-background-darker rounded-lg">
              <p className="text-sm text-gray-400">{selectedSlotInfo}</p>
            </div>
          </div>
        </div>

        <div className="bg-background-light rounded-xl p-6">
          <h3 className="text-lg font-semibold mb-4">Recent Games</h3>
          
          <div className="space-y-2">
            {history.length > 0 ? (
              history.map((game, index) => (
                <div
                  key={index}
                  className={`p-3 rounded-lg flex justify-between items-center ${
                    game.isWin ? 'bg-green-500/10' : 'bg-red-500/10'
                  }`}
                >
                  <div className="flex items-center space-x-2">
                    <span className={game.isWin ? 'text-green-400' : 'text-red-400'}>
                      {game.isWin ? 'WIN' : 'LOSS'}
                    </span>
                    <span className="text-xs text-gray-400">
                      {game.multiplier.toFixed(1)}x
                    </span>
                  </div>
                  <span className="font-semibold">
                    {currencySymbol}{game.amount}
                  </span>
                </div>
              ))
            ) : (
              <div className="text-gray-400 text-center py-4">
                No games played yet
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}