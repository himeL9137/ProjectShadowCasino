I need the Replit agent to fix and implement a **strict currency changing system** for **Project Shadow Casino**, an online casino app built with **TypeScript**, **React**, **Redux**, **Node.js**, **SQLite**, **WebSocket**, and **Tailwind CSS**. The app includes three games (**Slots**, **Dice**, **Plinko**) and a currency system supporting **USD**, **BDT**, **INR**, **BTC**, and **JPY**. Users must switch currencies at any time, including during active gameplay, with **no issues** (e.g., state loss, incorrect balances, UI glitches, or refresh requirements). The system must fix balance update issues (e.g., delayed updates, mismatches during currency switches) and enforce strict validation and real-time updates.

### Requirements:
1. **Currency System**:
   - Support five currencies: **USD**, **BDT**, **INR**, **BTC**, **JPY** with fixed exchange rates: USD: 1, BDT: 122.73, INR: 83.27, BTC: 0.000013, JPY: 145.00.
   - Allow currency switching anytime, including mid-game (e.g., during a spin in Slots, roll in Dice, or drop in Plinko).
   - Store balances in USD internally in SQLite, converting to the user’s currency for display using server-side exchange rates.
   - Save currency preference in SQLite and apply globally via Redux.
   - Use WebSocket (`socket.io`) for **instant, real-time balance updates** across all components (games, UI) without page refreshes.
   - Enforce **strict validation**: only allow valid currencies, reject invalid requests, and use atomic database transactions to prevent race conditions.
   - Format balances with `Intl.NumberFormat` for locale-specific display (e.g., ¥14,500 JPY, ₹8,327 INR).
   - Display error alerts for failed currency switches (e.g., network issues, invalid currency).

2. **Balance Update Fixes**:
   - Fix issues where balances don’t update instantly or mismatch during currency switches or gameplay.
   - Ensure **global consistency**: all components (games, UI) reflect the latest balance after bets, wins, or currency changes.
   - Prevent race conditions by disabling game actions during active gameplay (e.g., `isSpinning`) and using atomic backend updates.
   - Update balances via Redux (`setBalance`) and WebSocket (`balanceUpdate`) after every game action or currency switch.
   - Validate bets against the current balance to prevent overspending.

3. **Games (Slots, Dice, Plinko)**:
   - Embed a currency selector in each game for mid-game switching.
   - Implement biased RNG: 50/50 win chance for balances < 150 (in user’s currency); otherwise, fixed win chances of 0.8, 0.4, or 0.2. Payout is 1.1x win or loss.
   - Persist game state (e.g., `isSpinning`, `isRolling`, `isDropping`) during currency switches to avoid disruptions.
   - Adjust bets automatically after currency switches to stay valid (e.g., within new balance).
   - Display errors for invalid bets or failed balance updates.

4. **UI and Styling**:
   - Use Tailwind CSS with a dark purple theme (project default).
   - Ensure responsive design with disabled states for buttons/inputs during gameplay.
   - Display bets and balances clearly, updating instantly after currency switches.

5. **Backend**:
   - Use Node.js with Express and SQLite.
   - Implement endpoints:
     - `PATCH /api/user/currency`: Update currency and convert balance.
     - `PATCH /api/user/balance`: Update balance after game actions.
   - Assume JWT authentication (middleware sets `req.user`).
   - Use async/await with promises for atomic SQLite updates.
   - Broadcast balance changes via WebSocket to all clients.

6. **Replit Optimization**:
   - Provide a complete file structure compatible with Replit.
   - Include `package.json` with dependencies (e.g., `react`, `redux`, `socket.io`, `sqlite3`, `tailwindcss`, `typescript`).
   - Provide a `.replit` file to run backend and frontend (e.g., `npm run start` for backend, `npm run dev` for frontend).
   - Use Replit’s external URL for WebSocket (e.g., `https://<repl-id>.repl.co`) instead of `localhost:5000`.
   - Ensure SQLite database is initialized with the provided schema.
   - Include a basic JWT auth system (e.g., `/api/auth/login`) for testing.

### Reference Code:
Use the following code as a base (from artifact_id: `3ee44dce-0c75-4baa-9050-9265b0fd53e8`). Fix balance update issues, enforce strict currency rules, and optimize for Replit.

```typescript
// Frontend: src/components/CurrencySelector.tsx
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { setCurrency, setBalance } from '../redux/slices/userSlice';
import { RootState } from '../redux/store';
import { io } from 'socket.io-client';

const socket = io('https://<repl-id>.repl.co'); // Use Replit URL

interface CurrencySelectorProps {
  onCurrencyChange?: () => void;
}

const CurrencySelector: React.FC<CurrencySelectorProps> = ({ onCurrencyChange }) => {
  const dispatch = useDispatch();
  const { currency, balance } = useSelector((state: RootState) => state.user);
  const [error, setError] = useState<string | null>(null);
  const availableCurrencies = ['USD', 'BDT', 'INR', 'BTC', 'JPY'];

  const exchangeRates: { [key: string]: number } = {
    USD: 1,
    BDT: 122.73,
    INR: 83.27,
    BTC: 0.000013,
    JPY: 145.00,
  };

  const formatBalance = (amount: number, curr: string): string => {
    try {
      const locales: { [key: string]: string } = {
        USD: 'en-US',
        BDT: 'bn-BD',
        INR: 'hi-IN',
        BTC: 'en-US',
        JPY: 'ja-JP',
      };
      return new Intl.NumberFormat(locales[curr], {
        style: 'currency',
        currency: curr,
        minimumFractionDigits: curr === 'BTC' ? 8 : 2,
      }).format(amount);
    } catch {
      return `${amount.toFixed(curr === 'BTC' ? 8 : 2)} ${curr}`;
    }
  };

  const handleCurrencyChange = async (newCurrency: string) => {
    if (!availableCurrencies.includes(newCurrency)) {
      setError('Invalid currency');
      return;
    }
    try {
      setError(null);
      const response = await fetch('/api/user/currency', {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({ currency: newCurrency }),
      });

      if (!response.ok) throw new Error('Failed to update currency');

      const data = await response.json();
      dispatch(setCurrency(newCurrency));
      dispatch(setBalance(data.balance));
      socket.emit('currencyChange', { userId: localStorage.getItem('userId'), currency: newCurrency });
      if (onCurrencyChange) onCurrencyChange();
    } catch (error) {
      console.error('Currency update error:', error);
      setError('Failed to switch currency. Please try again.');
    }
  };

  useEffect(() => {
    socket.on('balanceUpdate', (data: { balance: number; currency: string }) => {
      dispatch(setCurrency(data.currency));
      dispatch(setBalance(data.balance));
      if (onCurrencyChange) onCurrencyChange();
    });

    return () => {
      socket.off('balanceUpdate');
    };
  }, [dispatch, onCurrencyChange]);

  return (
    <div className="currency-selector flex items-center gap-2">
      <label htmlFor="currency" className="text-sm">Currency:</label>
      <select
        id="currency"
        value={currency}
        onChange={(e) => handleCurrencyChange(e.target.value)}
        className="p-1 border rounded text-sm"
      >
        {availableCurrencies.map((curr) => (
          <option key={curr} value={curr}>
            {curr}
          </option>
        ))}
      </select>
      <p className="text-sm">{formatBalance(balance, currency)}</p>
      {error && <p className="text-red-500 text-xs">{error}</p>}
    </div>
  );
};

export default CurrencySelector;

// Frontend: src/games/Slots.tsx
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { setBalance } from '../redux/slices/userSlice';
import { RootState } from '../redux/store';
import CurrencySelector from '../components/CurrencySelector';

const Slots: React.FC = () => {
  const dispatch = useDispatch();
  const { currency, balance } = useSelector((state: RootState) => state.user);
  const [bet, setBet] = useState(1);
  const [isSpinning, setIsSpinning] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const exchangeRates: { [key: string]: number } = {
    USD: 1,
    BDT: 122.73,
    INR: 83.27,
    BTC: 0.000013,
    JPY: 145.00,
  };

  const handleSpin = async () => {
    if (isSpinning || bet > balance || bet <= 0) {
      setError(bet > balance ? 'Insufficient balance' : 'Invalid bet');
      return;
    }
    setIsSpinning(true);
    setError(null);

    const isLowBalance = balance < 150 / exchangeRates[currency];
    const winChance = isLowBalance ? 0.5 : [0.8, 0.4, 0.2][Math.floor(Math.random() * 3)];
    const result = Math.random() < winChance ? bet * 1.1 : 0;
    const newBalance = balance - bet + result;

    try {
      const response = await fetch('/api/user/balance', {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({ balance: newBalance }),
      });

      if (!response.ok) throw new Error('Failed to update balance');

      dispatch(setBalance(newBalance));
      socket.emit('balanceUpdate', { userId: localStorage.getItem('userId'), balance: newBalance, currency });
    } catch (error) {
      console.error('Balance update error:', error);
      setError('Failed to update balance. Please try again.');
    }
    setIsSpinning(false);
  };

  const handleCurrencyChange = () => {
    setBet(Math.max(1, Math.min(balance, bet)));
    setError(null);
  };

  return (
    <div className="slots-game p-4 bg-gray-800 text-white rounded">
      <CurrencySelector onCurrencyChange={handleCurrencyChange} />
      <div className="game-controls flex gap-2 mt-2">
        <input
          type="number"
          value={bet}
          onChange={(e) => setBet(Number(e.target.value))}
          min="1"
          max={balance}
          className="p-2 border rounded text-black"
          disabled={isSpinning}
        />
        <button
          onClick={handleSpin}
          disabled={isSpinning || bet > balance || bet <= 0}
          className="p-2 bg-purple-600 text-white rounded disabled:opacity-50"
        >
          {isSpinning ? 'Spinning...' : 'Spin'}
        </button>
      </div>
      <p className="mt-2">Current Bet: {bet.toFixed(2)} {currency}</p>
      {error && <p className="text-red-500 text-xs mt-2">{error}</p>}
    </div>
  );
};

export default Slots;

// [Include Dice.tsx, Plinko.tsx, userSlice.ts, currencyRoutes.ts, index.ts from artifact_id: 3ee44dce-0c75-4baa-9050-9265b0fd53e8, with fixes for balance updates and Replit compatibility]
```

### Fixes Required:
- **Balance Updates**: Ensure balances update instantly across all components after bets, wins, or currency switches. Fix delays or mismatches by strengthening WebSocket and Redux integration.
- **Strict Validation**: Reject invalid currencies or negative balances. Use atomic SQLite transactions to prevent partial updates.
- **Replit Compatibility**: Replace `localhost:5000` with Replit’s external URL. Ensure WebSocket works in Replit’s hosted environment.
- **Error Handling**: Enhance error messages for failed updates or switches, ensuring users are informed without breaking the UI.

### Deliverables:
- Complete file structure (e.g., `src/client`, `src/server`).
- `package.json` with all dependencies.
- `.replit` file to run backend and frontend.
- README with setup and run instructions (e.g., initialize SQLite, generate JWT token).
- Basic JWT auth implementation for testing.
- Ensure the system is production-ready for Replit, with no runtime errors (e.g., “Unexpected token '<'”).

Please implement the fixed currency changing system, optimizing the reference code for strictness, reliability, and Replit compatibility. Test currency switches mid-game (e.g., 100 USD to 14,500 JPY during a Plinko drop) to verify instant updates and no issues. Provide a complete, runnable project.